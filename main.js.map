{"version":3,"file":"main.js","mappings":"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","sources":["webpack://battleship-project/webpack/bootstrap","webpack://battleship-project/webpack/runtime/global","webpack://battleship-project/webpack/runtime/publicPath","webpack://battleship-project/./src/ship.js","webpack://battleship-project/./src/gameboard.js","webpack://battleship-project/./src/player.js","webpack://battleship-project/./src/logger.js","webpack://battleship-project/./src/game.js","webpack://battleship-project/./src/drag_drop.js","webpack://battleship-project/./src/board_renderer.js","webpack://battleship-project/./src/render.js","webpack://battleship-project/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export default class Ship {\n  #timesHit = 0;\n  #sunk = false;\n  #direction;\n  constructor(length) {\n    if (length === undefined || Number.isInteger(length) === false)\n      throw new Error(\"Lenght must be provided\");\n    this.length = length;\n  }\n  hit() {\n    this.#timesHit++;\n  }\n  isSunk() {\n    return this.#timesHit >= this.length;\n  }\n  setDirection(direction) {\n    this.#direction = direction;\n  }\n  getDirection() {\n    return this.#direction;\n  }\n}\n","import Ship from \"./ship\";\n\nexport default class Gameboard {\n  //missed shots coordinate are not zero indexed\n  missedShots = [];\n  attacksReceived = [];\n  //TODO change to board instead of coordinates to avoid confusion\n  coordinates;\n\n  constructor() {\n    this.coordinates = new Map();\n  }\n  static splitColumnRow(stringCoordinates) {\n    const [column, row] = [\n      stringCoordinates[0],\n      stringCoordinates.substring(1),\n    ];\n    return [column, row];\n  }\n  clearGameboard() {\n    //this is not pure\n    this.coordinates = this.#clear(this.coordinates);\n    this.missedShots = this.#clear(this.missedShots);\n    this.attacksReceived = this.#clear(this.attacksReceived);\n  }\n  //violating open/closed principle, but the other options take a long time to implement, is not time effective\n  #clear(value) {\n    let returnVal;\n    switch (value.constructor.name) {\n      case \"Array\":\n        returnVal = [];\n        break;\n      case \"Object\":\n        returnVal = {};\n        break;\n      case \"Map\":\n        //should I clear or return a new map ?\n        returnVal = new Map();\n        break;\n      default:\n        throw new TypeError(\"Value should be an array or an object literal\");\n    }\n    return returnVal;\n  }\n  #isCoordinateOccupied(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.has(coordinate);\n  }\n  getCoordinate(column, row) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(`Invalid coordinate at ${(column, row)}`);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.get(coordinate);\n  }\n  updateCoordinate(column, row, value) {\n    throw new Error(\"Not implemented\");\n  }\n  setCoordinate(column, row, value) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(\"Invalid coordinate\", {\n        cause: { column: column, row: row },\n      });\n    if (this.#isCoordinateOccupied(column, row) === true) {\n      throw new Error(\n        \"Coordinate already taken, to overwrite use updateCoordinate\",\n        {\n          cause: { column: column, row: row },\n        }\n      );\n    }\n    //shallow copy the map\n    const newCoordinates = new Map(this.coordinates);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    newCoordinates.set(coordinate, value);\n    this.coordinates = newCoordinates;\n  }\n  #toBoardCoordinates(column, row) {\n    const coordinate = column + row.toString();\n    return coordinate;\n  }\n  //it actually states that placeShip should make a new instance of ship, but how is the player going to decide which ship it is?\n  placeShip(column, row, length, direction = \"horizontal\") {\n    if (direction !== \"horizontal\" && direction !== \"vertical\")\n      throw new Error(\"Invalid direction: should be horizontal or vertical\");\n    const ship = new Ship(length);\n    let currentLen = 1;\n    const coordinatesBackup = this.coordinates;\n    try {\n      this.setCoordinate(column, row, ship);\n      ship.setDirection(direction);\n      this.#spreadShip(column, row, ship, direction, length);\n    } catch (e) {\n      //TODO implement a decent error handler\n      if (\n        e.message === \"Invalid coordinate\" ||\n        e.message === \"Coordinate already taken\"\n      )\n        //would be good if I could get which coordinates got this error\n        console.error(`Failed at ${JSON.stringify(e.cause)}, ${e.message}`);\n      this.coordinates = coordinatesBackup;\n      throw new Error(`${e.message} at ${e.cause.column}${e.cause.row}`);\n    }\n  }\n  #spreadShip(column, row, ship, direction, length) {\n    let currentLen = 1;\n    //ship.length was causing the test not to work because it is an empty mock, not a mock implementation\n    while (currentLen < length) {\n      if (direction === \"horizontal\") {\n        column = this.#increaseHorizontal(column);\n      } else {\n        row = this.#increaseVertical(row);\n      }\n      currentLen++;\n      this.setCoordinate(column, row, ship);\n    }\n  }\n\n  receiveAttack(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    const ship = this.getCoordinate(column, row);\n    const receivedHits = this.attacksReceived.concat(this.missedShots);\n    if (receivedHits.includes(coordinate) === true)\n      throw new Error(\n        `Unable to attack: coordinate has already been hit at ${column}${row}`\n      );\n    else if (ship instanceof Ship) {\n      ship.hit();\n      this.#recordAttack(column, row);\n      return true;\n    }\n    this.#recordMiss(column, row);\n    return false;\n  }\n  allSunk() {\n    if (this.coordinates.size < 1) {\n      return false;\n    }\n    return Array.from(this.coordinates.values()).every((ship) => {\n      return ship.isSunk() === true;\n    });\n  }\n  //TODO: How do I write a test for this?\n  static getRandomCoordinate() {}\n  //not pure\n  #recordMiss(column, row) {\n    const copyMissedShots = [...this.missedShots];\n    copyMissedShots.push(this.#toBoardCoordinates(column, row));\n    this.missedShots = copyMissedShots;\n  }\n  #recordAttack(column, row) {\n    const copyReceivedAttacks = [...this.attacksReceived];\n    copyReceivedAttacks.push(this.#toBoardCoordinates(column, row));\n    this.attacksReceived = copyReceivedAttacks;\n  }\n  #isCoordinateValid(column, row) {\n    //use regex here\n    if (\n      this.#isRowValid(row) === true &&\n      this.#isColumnValid(column) === true\n    ) {\n      return true;\n    }\n    return false;\n  }\n  #isRowValid(row) {\n    if (row > 10 || row < 1) {\n      return false;\n    }\n    return true;\n  }\n  #isColumnValid(column) {\n    const regex = /[A-J]/;\n    return regex.test(column);\n  }\n  #increaseHorizontal(column) {\n    const codeUnit = column.charCodeAt(0);\n    const newColumn = String.fromCharCode(codeUnit + 1);\n    return newColumn;\n  }\n  #increaseVertical(row) {\n    return Number.parseInt(row) + 1;\n  }\n}\n","import Gameboard from \"./gameboard\";\n\nexport default class Player {\n  #type = null;\n  name;\n  gameboard;\n  constructor(type, name) {\n    this.gameboard = new Gameboard();\n    this.name = name;\n    if (type) this.type = type;\n  }\n  set type(playerType) {\n    if (playerType !== \"real\" && playerType !== \"computer\")\n      throw new TypeError(\"Playertype should be computer or real\");\n    this.#type = playerType;\n  }\n  get type() {\n    return this.#type;\n  }\n}\n","import \"./logger.css\";\nexport default class Logger {\n  #hitMessage = \"hit\";\n  #missMessage = \"missed\";\n  #sunkMessage = \"sunk\";\n  #element;\n  constructor() {\n    this.#element = this.buildLoggerEl();\n  }\n  getLogger() {\n    return this.#element;\n  }\n  buildLoggerEl() {\n    const logHeader = document.createElement(\"div\");\n    const logContainer = document.createElement(\"div\");\n    // logHeader.classList.add(\"log-header\");\n    logContainer.classList.add(\"log-container\");\n    // logHeader.append(logContainer);\n    return logContainer;\n  }\n  //   setAttackMessage(message=\"hit\"){\n  //     return message\n  //   }\n  //   setMissMessage(message)\n  logMessage(message, type, playerName) {\n    const spanEl = document.createElement(\"span\");\n    spanEl.classList.add(\"log-message\");\n    spanEl.classList.add(`log-${type}`);\n    spanEl.dataset.playerName = playerName ? playerName : \"\";\n    spanEl.textContent = message;\n    this.getLogger().insertBefore(spanEl, this.getLogger().firstChild);\n  }\n  logAttack(currPlayer, targetPlayer, coordinates, boolHit, sunk = false) {\n    // const messageEl = document.createElement(\"span\");\n    // messageEl.classList.add(\"log-message\");\n    let message = `${currPlayer} attacked coordinates ${coordinates} and `;\n    if (boolHit === true) {\n      message += `successfully ${this.#hitMessage} ${\n        sunk === true ? \"and sunk\" : \"\"\n      } ${targetPlayer}'s Ship`;\n    } else {\n      message += `${this.#missMessage} ${targetPlayer}'s Ships`;\n    }\n    this.logMessage(message, \"attack\", currPlayer);\n    // messageEl.textContent = message;\n    // this.getLogger().appendChild(messageEl);\n  }\n  //TODO\n  logStatus(currPlayer, { enemyPlayer, sunkShips, dealtAttacks, missedHits }) {\n    let message = `${currPlayer.name} Status: \\n\n    Enemy ships sunk: ${sunkShips} \\n\n    Attacks Dealt: ${dealtAttacks}\\n\n    Missed Hits: ${missedHits}\\n\n    `;\n    this.logMessage(message, \"status\");\n  }\n}\n","// import Gameboard from \"./gameboard\";\nimport Player from \"./player\";\nimport Logger from \"./logger.js\";\nimport Gameboard from \"./gameboard.js\";\n//this will serve as the mediator ?\nexport default class Game {\n  static players = [];\n  static stages = [\"start\", \"playerSetup\", \"playerMove\", \"gameOver\"];\n  static gameover = false;\n  static logger = new Logger();\n\n  //first item will be the current player\n  static player1;\n  static player2;\n  static currentPlayer;\n  static currentStage;\n\n  static SHIPS_TYPES = [\n    { name: \"Carrier\", length: 5 },\n    { name: \"Battleship\", length: 4 },\n    { name: \"Destroyer\", length: 3 },\n    { name: \"Submarine\", length: 3 },\n    { name: \"Patrol Boat\", length: 2 },\n  ];\n\n  static MAX_SHIPS = this.SHIPS_TYPES.length;\n  //shouldnt I manage the phases here ?\n  static get SHIP_MAX_SIZE() {\n    let maxSize = 0;\n    for (let { length } of Game.SHIPS_TYPES) {\n      maxSize = length > maxSize ? length : maxSize;\n    }\n    return maxSize;\n  }\n  static start(mode = 1) {\n    //populate the gameboard with predetermined coordinates\n    this.currentStage = \"start\";\n    if (mode === 1) {\n      Game.players.push(\n        new Player(\"real\", \"Player\"),\n        new Player(\"computer\", \"Computer\")\n      );\n    } else {\n      Game.players.push(\n        new Player(\"real\", \"Player 1\"),\n        new Player(\"real\", \"Player 2\")\n      );\n    }\n    [this.player1, this.player2] = this.players;\n    Game.currentPlayer = this.player1;\n    const nextStage = \"playerSetup\";\n\n    return (this.currentStage = nextStage);\n  }\n\n  //stages''\n  //This is not doing what it should\n  //it should get the positions on the board and place ships there\n\n  static playerSetup(coordArray) {\n    //should I call the next phase here?\n    this.currentStage = \"playerSetup\";\n    if (Game.allPlayersReady() === true) {\n      this.currentStage = \"playerMove\";\n      Game.switchPlayer();\n      return this.currentStage;\n    }\n\n    const currentPlayer = Game.currentPlayer;\n    //TODO get coordinates that event handler got\n    // for (const coord of coordArray) {\n    //   currentPlayer.gameboard.placeShip(...coord);\n    // }\n\n    //if player placed all ships correctly he can proceed to the next phase\n    if (Game.isPlayerReady(currentPlayer) === true) {\n      Game.switchPlayer();\n      return this.currentStage;\n    } else {\n      throw new Error(\"Player is not ready\");\n    }\n  }\n\n  //I should decide if it gets column,row or coordinates\n  //I can use the Gameboard.splitColumnRow here to get the column and row\n  static playerMove(attackCoordinates, waitTime = 0) {\n    const [column, row] = [\n      attackCoordinates[0],\n      attackCoordinates.substring(1),\n    ];\n    this.currentStage = \"playerMove\";\n    const enemyPlayer = this.getEnemyPlayer();\n    const hit = enemyPlayer.gameboard.receiveAttack(column, row);\n    const sunk =\n      hit === false\n        ? false\n        : enemyPlayer.gameboard.getCoordinate(column, row).isSunk();\n\n    this.logger.logAttack(\n      this.getCurrentPlayer().name,\n      this.getEnemyPlayer().name,\n      attackCoordinates,\n      hit,\n      sunk\n    );\n\n    if (this.isGameover()) {\n      this.currentStage = \"gameOver\";\n\n      return this.currentStage;\n    }\n    //insert gameovercheck\n    Game.switchPlayer();\n    return this.currentStage;\n  }\n  static computerPlayerMove() {\n    let nextStage;\n    let coordinates;\n    while (true) {\n      try {\n        coordinates = Game.generateRandomCoordinate();\n        return Game.playerMove(coordinates);\n      } catch (error) {\n        console.error(`tried at ${coordinates}, regenerating`);\n        if (error.message.includes(\"coordinate has already been hit\") === false)\n          throw error;\n      }\n    }\n  }\n  //should I move this to gameboard ?\n  static generateRandomCoordinate() {\n    const COLUMNS = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"];\n    const MINCOORDINATE = 1;\n    const MAXCOORDINATE = 10;\n    const randomRow = Math.floor(\n      Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n    );\n    //-1 at the end because arrays are zero indexed\n    const randomCol =\n      COLUMNS[\n        Math.floor(\n          Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n        ) - 1\n      ];\n\n    return randomCol.concat(randomRow);\n  }\n  //not pure\n  static isGameover() {\n    //TODO im checking only for the enemy player, should I check for all just to make sure?\n    this.gameover = this.players.some(\n      (player) => player.gameboard.allSunk() === true\n    );\n\n    return this.gameover;\n    // const enemyPlayer = Game.getEnemyPlayer();\n    // return enemyPlayer.gameboard.allSunk();\n  }\n  static finalStatus(player) {\n    const [enemy] = this.players.filter((p) => p !== player);\n    const gameboard = enemy.gameboard;\n    const ships = Array.from(new Set(gameboard.coordinates.values()));\n    const shipsSunk = ships.filter((ship) => ship.isSunk() === true);\n    const status = {\n      player: player,\n      attacksReceived: gameboard.attacksReceived.length,\n      missedShotsReceived: gameboard.missedShots.length,\n      sunkShips: shipsSunk.length,\n    };\n    this.logger.logStatus(player, {\n      enemyPlayer: enemy,\n      sunkShips: status.sunkShips,\n      dealtAttacks: status.attacksReceived,\n      missedHits: status.missedShotsReceived,\n    });\n  }\n  static getWinner() {\n    if (this.gameover === false) return;\n    const [winner] = this.players.filter(\n      (player) => player.gameboard.allSunk() === false\n    );\n    return winner;\n  }\n  static getEnemyPlayer() {\n    const [enemyPlayer] = this.players.filter(\n      (element) => element !== Game.getCurrentPlayer()\n    );\n\n    return enemyPlayer;\n  }\n  static getCurrentPlayer() {\n    return Game.currentPlayer;\n  }\n  static getCurrentStage() {\n    return Game.currentStage;\n  }\n  static switchPlayer() {\n    let oldCurrPlayer = this.currentPlayer;\n    this.currentPlayer =\n      this.currentPlayer === this.player1 ? this.player2 : this.player1;\n  }\n  static populatePredetermined(player, coordArray) {\n    player.gameboard.clearGameboard();\n    const predeterminedCoord = [\n      [\"A\", 1, 5, \"horizontal\"],\n      [\"D\", 5, 3, \"vertical\"],\n      [\"A\", 3, 4, \"vertical\"],\n      [\"A\", 8, 3, \"horizontal\"],\n      [\"A\", 10, 2, \"horizontal\"],\n    ];\n    for (const coord of predeterminedCoord) {\n      Game.getCurrentPlayer().gameboard.placeShip(...coord);\n    }\n  }\n  static populateGameboard(player) {\n    player.gameboard.clearGameboard();\n    const avaiableShips = Game.SHIPS_TYPES;\n    for (let ship of avaiableShips) {\n      let shipSize = ship.length;\n      while (true) {\n        let coordinates;\n        let randomDirection;\n        let column;\n        let row;\n        try {\n          coordinates = Game.generateRandomCoordinate();\n          randomDirection =\n            Math.floor(Math.random() * 2) === 0 ? \"vertical\" : \"horizontal\";\n          [column, row] = Gameboard.splitColumnRow(coordinates);\n          player.gameboard.placeShip(column, row, shipSize, randomDirection);\n          break;\n        } catch (error) {\n          if (\n            error.message.includes(\"Coordinate already taken\") ||\n            error.message.includes(\"Invalid coordinate\")\n          ) {\n            console.error(\n              `tried to place at ${coordinates}, separated ${column},${row}, regenerating`\n            );\n          } else {\n            throw error;\n          }\n        }\n      }\n    }\n  }\n  static isPlayerReady(player) {\n    const uniqueShipsInstances = new Set(player.gameboard.coordinates.values());\n    const cellsOccupied = this.SHIPS_TYPES.reduce((sum, curr) => {\n      return curr.length + sum;\n    }, 0);\n    return (\n      uniqueShipsInstances.size === this.MAX_SHIPS &&\n      player.gameboard.coordinates.size === cellsOccupied\n    );\n  }\n  static allPlayersReady() {\n    return this.players.every((player) => this.isPlayerReady(player) === true);\n  }\n}\n//TODO LET GAME HANDLE GAME PHASES\n","export default class DragAndDrop {\n  static #dropStatus = \"\";\n  static dragstartEvent(shipName, shipLength) {\n    DragAndDrop.#dropStatus = \"\";\n\n    return function dragEventHandler(e) {\n      e.dataTransfer.setData(\"shipName\", shipName);\n      e.dataTransfer.setData(\"shipLength\", shipLength);\n      e.dataTransfer.setData(\n        \"shipDirection\",\n        e.target.nextSibling.dataset.direction\n      );\n\n      // e.dataTransfer.setDragImage(e.target, 40, 40);\n    };\n  }\n  static dragendHandler(e) {\n    if (\n      e.dataTransfer.dropEffect === \"move\" &&\n      DragAndDrop.#dropStatus === \"Success\"\n    ) {\n      e.target.parentElement.remove();\n      console.log(\"dragend success\");\n    } else {\n      console.log(\"dragend failed\");\n    }\n  }\n\n  static dropEventHandler(event) {\n    //TODO can I put the remove event listener here ?\n\n    event.preventDefault();\n\n    const [col, row] = [\n      event.target.dataset.coordinates[0],\n      event.target.dataset.coordinates.substring(1),\n    ];\n    const shipLen = Number.parseInt(event.dataTransfer.getData(\"shipLength\"));\n    const shipName = event.dataTransfer.getData(\"shipName\");\n    const shipDirection = event.dataTransfer.getData(\"shipDirection\");\n    //TOFIX: if ship was already placed, position should be updated instead of placing another copy\n    //FIXED: WHEN PASSING A DIRECTION OTHER THAN HORIZONTAL A 1 GETS ADDED\n    //TOFIX: When failing placing the ship, shouldnt interrupt the whole program anymore\n    try {\n      this.player.gameboard.placeShip(col, row, shipLen, shipDirection);\n      this.updateBoard();\n    } catch (err) {\n      if (\n        err.message.includes(\"Invalid coordinate\") ||\n        err.message.includes(\"Coordinate already taken\")\n      ) {\n        //this is not going to work, dropEffect cant be changed on drop\n        DragAndDrop.#dropStatus = \"Fail\";\n        event.dataTransfer.dropEffect = \"none\";\n        return;\n      }\n      throw err;\n      //notify logger\n    }\n    DragAndDrop.#dropStatus = \"Success\";\n    // event.dataTransfer.dropEffect = \"move\";\n\n    //I can either make it unable to drag after placing or\n    //implement something that removes the ship\n\n    //Dragend fires an event at the object that was being dragged, i can use it to remove the drag\n    //or I can make an array that controls\n  }\n  static dragoverEventHandler(event) {\n    if (event.target.dataset.coordinates === undefined) {\n      console.log(\"dragover aborting\");\n      return;\n    }\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n  }\n}\n","import DragAndDrop from \"./drag_drop\";\nimport Game from \"./game\";\nimport { Render } from \"./render\";\nimport { renderUtil } from \"./render\";\nimport hitImg from \"./assets/hit.png\";\nimport missImg from \"./assets/miss.png\";\nimport shipImg from \"./assets/ship.png\";\nimport shipEndImg from \"./assets/shipEnd.png\";\nimport shipEndVerticalImg from \"./assets/shipEndVertical.png\";\nimport shipStartImg from \"./assets/shipStart.png\";\nimport shipStartVerticalImg from \"./assets/shipStartVertical.png\";\nimport shipMiddleImg from \"./assets/shipMiddle.png\";\nimport shipMiddleVerticalImg from \"./assets/shipMiddleVertical.png\";\n\nexport class BoardRenderer {\n  rows;\n  columns;\n  className;\n  renderedBoard;\n  player;\n  grouped = null;\n  static TIME_FOR_HIT_FEEDBACK = 1200;\n  static shipParts = {\n    verticalMiddle: shipMiddleVerticalImg,\n    verticalStart: shipStartVerticalImg,\n    verticalEnd: shipEndVerticalImg,\n    horizontalStart: shipStartImg,\n    horizontalEnd: shipEndImg,\n    horizontalMiddle: shipMiddleImg,\n  };\n  constructor(player, rows = 10, columns = 10, className = \"board-container\") {\n    this.rows = rows;\n    this.columns = columns;\n    this.className = className;\n    this.player = player;\n    this.init(rows, columns, className);\n    BoardRenderer.preloadImgs();\n  }\n  static preloadImgs() {\n    Object.values(this.shipParts).forEach((imgSrc) => {\n      const img = new Image();\n      img.src = imgSrc;\n    });\n  }\n  init() {\n    const rows = this.rows;\n    const columns = this.columns;\n    const className = this.className;\n    const cellNumber = columns * rows;\n    const alphabet = \"ABCDEFGHIJ\";\n    const cells = [];\n    //row 0 is the label for the columns\n    //column 0 is the label for the rows\n\n    for (let row = 0; row <= rows; row++) {\n      for (let column = 0; column <= columns; column++) {\n        const cell = document.createElement(\"div\");\n        cell.dataset.column = column;\n        cell.dataset.row = row;\n        cell.dataset.isLabel = true;\n        if (row > 0 && column > 0) {\n          //strings are zero indexed but the column is not\n          cell.dataset.isLabel = false;\n          cell.dataset.coordinates = `${alphabet[column - 1]}${row}`;\n        }\n\n        cells.push(cell);\n      }\n    }\n\n    const boardContainer = renderUtil.makeElement(\"div\", className, ...cells);\n    boardContainer.dataset.player = this.player.name;\n    this.renderedBoard = boardContainer;\n\n    // return boardContainer;\n  }\n  highlightBoard(bool) {\n    if (bool === true) this.renderedBoard.classList.add(\"highlight\");\n    else this.renderedBoard.classList.remove(\"highlight\");\n  }\n  getRenderedBoard() {\n    return this.renderedBoard;\n  }\n  initListener() {\n    this.getRenderedBoard().addEventListener(\"click\", this);\n  }\n  amIEnemy() {\n    return Game.getEnemyPlayer() === this.player;\n  }\n  updateBoard() {\n    this.grouped = this.groupCoordinatesByInstance();\n    if (this.amIEnemy() === true) {\n      //need to see my ships and enemy players hits\n      //I am the current player\n\n      this.enemyView();\n      return;\n    } else {\n      //if im the enemy player, the current player needs to see\n      //my attacks received, missed hits\n      this.allyView();\n    }\n  }\n  revealBoard() {\n    this.allyView();\n  }\n  //REFACTOR\n  enemyView(gameboardInstance) {\n    this.renderedBoard.dataset.playerStatus = \"enemy\";\n    this.highlightBoard(true);\n    const missedHits = this.player.gameboard.missedShots;\n    const attacksReceived = this.player.gameboard.attacksReceived;\n\n    this.loopBoard((cell) => {\n      if (missedHits.includes(cell.dataset.coordinates)) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (attacksReceived.includes(cell.dataset.coordinates)) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n  allyView(gameboardInstance) {\n    //!!\n\n    this.renderedBoard.dataset.playerStatus = \"ally\";\n    this.highlightBoard(false);\n    //TODO can make the loop make three arrays and then we assign the content to those depending on type of array\n\n    this.loopBoard((cell) => {\n      //if gameboard coordinates matches missed shots or attacks received or coordinates\n      //change text content(img later) to match according to what it is\n      //board is updated whenever places ship\n      //REFACTOR\n      //TODO separate the stylying for each cell status\n      if (\n        this.player.gameboard.attacksReceived.includes(cell.dataset.coordinates)\n      ) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else if (\n        this.player.gameboard.missedShots.includes(cell.dataset.coordinates)\n      ) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (\n        this.player.gameboard.coordinates.has(cell.dataset.coordinates)\n      ) {\n        cell.replaceChildren(this.renderShip(cell.dataset.coordinates));\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n\n  clickBoardEvent(event) {\n    if (this.amIEnemy() === true) {\n      return event.target.dataset.coordinates;\n    }\n  }\n  loopBoard(callback) {\n    for (let cell of this.renderedBoard.children) {\n      if (cell.dataset.isLabel === \"true\") {\n        continue;\n      }\n\n      callback(cell);\n    }\n  }\n  handleEvent(event) {\n    if (event.target.dataset.coordinates === undefined) return;\n    //Refactor give the event to each handler properly\n    if (event.type === \"drop\") this.dropEventHandler(event);\n    if (event.type === \"dragover\") this.dragoverEventHandler(event);\n    if (event.type !== \"click\") return;\n    if (Game.getCurrentStage() === \"playerMove\" && this.amIEnemy() === true) {\n      const attackCoordinates = this.clickBoardEvent(event);\n      const nextRenderPhase = Game.playerMove(attackCoordinates);\n\n      this.getRenderedBoard().removeEventListener(\"click\", this);\n      // this.updateBoard();\n      //Because playerMove changed the active player, update board will detect the current board as an ally instead of enemy, so we override it to be enemyView\n      //THIS ALSO INTRODUCES A BUG, IN WHICH IF YOU CLICK ON YOUR BOARD BEFORE THE TIME YOU CAN ATTACK IT\n      //Fixed by disabling pointer events and by placing listener on the enemy board ONLY and removing it later\n      this.enemyView();\n\n      setTimeout(() => {\n        if (this.player.type === \"computer\") {\n          Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n        } else {\n          Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"]);\n        }\n      }, BoardRenderer.TIME_FOR_HIT_FEEDBACK);\n    }\n  }\n\n  //make this fun reference the other fun\n  dropEventHandler(event) {\n    if (Game.getCurrentStage() !== \"playerSetup\") return;\n    DragAndDrop.dropEventHandler.call(this, event);\n  }\n\n  dragoverEventHandler(event) {\n    DragAndDrop.dragoverEventHandler.call(this, event);\n  }\n  groupCoordinatesByInstance() {\n    //I only need to run this after setup, then I can use the stored value and apply a tag for hit\n    const gameboard = this.player.gameboard;\n    const coordinatesByShips = new Map();\n    //grouping by instances\n    for (let [coordinate, instance] of gameboard.coordinates) {\n      if (coordinatesByShips.has(instance) === true) {\n        coordinatesByShips.get(instance).push(coordinate);\n      } else {\n        coordinatesByShips.set(instance, [coordinate]);\n      }\n    }\n    //Sort so its either A1 A2 A3(vertical) or A1 B1 C1(horizontal)\n    //its already sorted\n    // coordinatesByShips.forEach((val, key) => val.sort());\n\n    return coordinatesByShips;\n  }\n  renderShip(cellCoordinate) {\n    const groupedCoord = this.grouped;\n    const coordinates = this.player.gameboard.coordinates;\n    //I should only loop through the cells that have a ship, or, cells that are in the coordinates array\n\n    if (coordinates.has(cellCoordinate)) {\n      const shipInstance = coordinates.get(cellCoordinate);\n      //all the coordinates that ship occupies\n      const shipCoordinatesArr = groupedCoord.get(shipInstance);\n      //which part is this? Start, middle or end ?\n      const part = this.#assignShipParts(\n        shipCoordinatesArr,\n        shipInstance.getDirection(),\n        cellCoordinate\n      );\n      const partImg = new Image();\n      partImg.src = part;\n      return partImg;\n\n      //DONE change this to only receive the coordinates and decide which part is\n      // - should return the part\n      // - should not loop\n    }\n  }\n\n  //decides if its a middle, start or end part\n  #assignShipParts(coordinatesOccupiedByShip, shipDirection, coordinates) {\n    const part = coordinatesOccupiedByShip.indexOf(coordinates);\n    const result = coordinatesOccupiedByShip.length - part;\n    // return this.shipParts[shipDirection + result]\n\n    if (result === 1) return BoardRenderer.shipParts[shipDirection + \"End\"];\n    else if (result === coordinatesOccupiedByShip.length)\n      return BoardRenderer.shipParts[shipDirection + \"Start\"];\n    else {\n      return BoardRenderer.shipParts[shipDirection + \"Middle\"];\n    }\n  }\n}\n","import \"./board.css\";\nimport Game from \"./game.js\";\nimport { BoardRenderer } from \"./board_renderer.js\";\nimport DragAndDrop from \"./drag_drop.js\";\nexport class Render {\n  static cachedDom = {\n    body: document.querySelector(\"body\"),\n    statusNav: document.querySelector(\".header\"),\n    mainContainer: document.querySelector(\".main-container\"),\n    domBoards: [],\n    logger: null,\n  };\n\n  static setHeader(title) {\n    this.cachedDom.statusNav.textContent = title;\n  }\n  static pastMovesList() {}\n\n  static gameStartScreen() {\n    //TODO memoize\n    const onePlayerBtn = document.createElement(\"button\");\n    const twoPlayersBtn = document.createElement(\"button\");\n    onePlayerBtn.classList.add(\"one-player-button\");\n    twoPlayersBtn.classList.add(\"two-player-button\");\n    onePlayerBtn.textContent = \"One player Mode\";\n    twoPlayersBtn.textContent = \"Two players Mode\";\n    //TODO: No need to repeat, clean this up later\n    onePlayerBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(1);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    twoPlayersBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(2);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    Render.cachedDom.mainContainer.replaceChildren(onePlayerBtn, twoPlayersBtn);\n    Render.cachedDom.mainContainer.classList.add(\"game-start-phase\");\n    this.cachedDom.statusNav.textContent = \"BattleShip\";\n  }\n  static updateCachedBoards() {\n    this.cachedDom.domBoards.forEach((element) => element.updateBoard());\n    return this.cachedDom.domBoards;\n  }\n  //BUG: stage isnt changing to playerSetup\n  static playerSetupScreen(currentPlayer) {\n    this.cachedDom.mainContainer.classList.add(\"player-setup-phase\");\n    const board = new BoardRenderer(Game.getCurrentPlayer());\n\n    if (Game.getCurrentPlayer().type === \"computer\") {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      setupDone();\n      return;\n    }\n    Render.setHeader(`${Game.getCurrentPlayer().name}'s Turn - Setup Phase`);\n    const shipsDiv = renderUtil.makeElement(\"div\", \"ship-placement-container\");\n    const shipsMenuEl = renderUtil.makeShipsMenu(Game.SHIPS_TYPES);\n    const populateBtn = document.createElement(\"button\");\n    const doneBtn = document.createElement(\"button\");\n    const clearBtn = document.createElement(\"button\");\n    clearBtn.textContent = \"Reset\";\n    populateBtn.textContent = `Populate ${Game.getCurrentPlayer().name} board`;\n    doneBtn.textContent = `Done`;\n\n    clearBtn.addEventListener(\"click\", (event) => {\n      Game.currentPlayer.gameboard.clearGameboard();\n      board.updateBoard();\n      this.playerSetupScreen(Game.getCurrentPlayer());\n    });\n    populateBtn.addEventListener(\"click\", () => {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      shipsDiv\n        .querySelectorAll(\".ship-info-container\")\n        .forEach((part) => part.remove());\n      board.updateBoard();\n    });\n    doneBtn.addEventListener(\"click\", setupDone);\n    function setupDone(event) {\n      //fixed\n\n      const nextRenderPhase = Game.playerSetup();\n      Render.cachedDom.domBoards.push(board);\n      Render.cachedDom.mainContainer.classList.remove(\"player-setup-phase\");\n\n      // Render.cachedDom.renderedBoards.push(board);\n      Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"], 500);\n    }\n\n    shipsDiv.append(shipsMenuEl, clearBtn, populateBtn, doneBtn);\n    board.getRenderedBoard().addEventListener(\"drop\", board);\n    board.getRenderedBoard().addEventListener(\"dragover\", board);\n    this.cachedDom.mainContainer.replaceChildren(\n      shipsDiv,\n      board.getRenderedBoard()\n    );\n  }\n\n  //should I place update board here on the switching playerScreen  ?\n  //TODO this is wrong? Is there a need to return promise here?\n  static async nextScreen(nextScreenFun, time = 0) {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        // Game.switchPlayer();\n        nextScreenFun.call(this);\n      }, time);\n    });\n  }\n  static async switchingPlayerScreen(nextScreenFun, time = 500) {\n    const switching = document.createElement(\"p\");\n    switching.textContent = \"Switching players, please hold . . . \";\n    this.cachedDom.statusNav.textContent = `Switching from ${\n      Game.getEnemyPlayer().name\n    } to ${Game.getCurrentPlayer().name}`;\n\n    Render.cachedDom.mainContainer.replaceChildren(switching);\n    await Render.nextScreen(nextScreenFun, time);\n\n    //set a timer to change the screen and board to the other player\n  }\n\n  //REFACTOR clean up this is messy\n  static playerMoveScreen() {\n    this.setHeader(`${Game.getCurrentPlayer().name}'s Turn`);\n\n    //TODO next: Decide also if the two boards are going to be p1 board and p2 board or enemy and currentplayer board\n    if (this.cachedDom.logger === null) {\n      const logger = Game.logger;\n      this.cachedDom.logger = logger;\n      this.cachedDom.body.append(logger.getLogger());\n    }\n    this.cachedDom.mainContainer.classList.add(\"player-move-phase\");\n\n    if (Game.currentPlayer.type === \"computer\") {\n      let playerBoard;\n      let computerBoard;\n      this.cachedDom.domBoards.forEach((board) => {\n        if (board.player.type === \"computer\") computerBoard = board;\n        else playerBoard = board;\n      });\n\n      playerBoard.highlightBoard(true);\n      computerBoard.getRenderedBoard().classList.add(\"dim\");\n      const nextRenderPhase = Game.computerPlayerMove();\n      setTimeout(() => {\n        playerBoard.highlightBoard(false);\n        computerBoard.getRenderedBoard().classList.remove(\"dim\");\n        Render[nextRenderPhase + \"Screen\"]();\n      }, BoardRenderer.TIME_FOR_HIT_FEEDBACK);\n\n      return;\n    }\n    //DONE stop making new boards\n    //DONE make board in the same position so theres no changing around each round\n    const [player1Board, player2Board] = this.updateCachedBoards();\n\n    //Refactor: Change this to a function that handles rendering the board altogether so I can reuse it on gameover scene\n    //I can also just cache this screen and reuse it\n    const boardContainers = renderUtil.makeBoardContainers(\n      player1Board,\n      player2Board\n    );\n\n    this.cachedDom.mainContainer.replaceChildren(boardContainers);\n    //REFACTOR change to handleEvent on the board\n    //listener is on the board\n    const [enemyBoard] = this.cachedDom.domBoards.filter(\n      (board) => board.amIEnemy() === true\n    );\n    enemyBoard.getRenderedBoard().addEventListener(\"click\", enemyBoard);\n    //TODO implement gameover check\n  }\n  static gameOverScreen() {\n    this.cachedDom.mainContainer.classList.remove(\"player-move-phase\");\n    const [player1Board, player2Board] = this.cachedDom.domBoards;\n    player1Board.revealBoard();\n    player2Board.revealBoard();\n\n    Render.cachedDom.mainContainer.replaceChildren(\n      player1Board.getRenderedBoard(),\n      player2Board.getRenderedBoard()\n    );\n    Game.finalStatus(Game.getCurrentPlayer());\n    Game.finalStatus(Game.getEnemyPlayer());\n    Render.setHeader(`${Game.getWinner().name} is the winner`);\n  }\n}\n//TODO change to upperCase\nexport class renderUtil {\n  static makeElement(element, className, ...childs) {\n    const myEl = document.createElement(element);\n    myEl.classList.add(className);\n    if (childs) {\n      myEl.append(...childs);\n    }\n    return myEl;\n  }\n  //todo\n  static makeBoardContainers(player1Board, player2Board) {\n    const boardContainers = renderUtil.makeElement(\"div\", \"board-containers\");\n    const board1HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    const board2HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    board1HeaderInfo.textContent = player1Board.player.name;\n    board2HeaderInfo.textContent = player2Board.player.name;\n    const board1InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board1HeaderInfo,\n      player1Board.getRenderedBoard()\n    );\n    const board2InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board2HeaderInfo,\n      player2Board.getRenderedBoard()\n    );\n    boardContainers.replaceChildren(board1InfoEl, board2InfoEl);\n    return boardContainers;\n  }\n\n  //TODO move this to drag and drop ?\n  static makeShipsMenu(SHIPS_TYPES) {\n    const menuElements = [];\n    for (let { name, length } of SHIPS_TYPES) {\n      // const shipViewEl = this.makeElement(\"div\", \"ship-view\");\n      let direction = \"horizontal\";\n      const shipViewEl = this.makeShipMenuImgs(length, direction);\n      //TODO finish draggable implementation\n      shipViewEl.draggable = true;\n\n      // shipViewEl.addEventListener(\"dragend\", (event) => {\n      //   const data = event.dataTransfer.getData(\"text\");\n      // });\n      const shipName = this.makeElement(\"p\", \"ship-name\");\n      const shipLength = this.makeElement(\"p\", \"ship-length\");\n      const shipDirection = this.makeElement(\"p\", \"ship-direction\");\n      shipName.textContent = name;\n      shipLength.textContent = length;\n      shipDirection.textContent = direction;\n      shipViewEl.addEventListener(\n        \"dragstart\",\n        DragAndDrop.dragstartEvent(name, length)\n      );\n      shipViewEl.addEventListener(\"dragend\", DragAndDrop.dragendHandler);\n\n      const shipInfoEl = this.makeElement(\n        \"div\",\n        \"ship-info\",\n        shipName,\n        shipLength,\n        shipDirection\n      );\n      shipInfoEl.dataset.direction = direction;\n      shipInfoEl.addEventListener(\"click\", (event) => {\n        event.currentTarget.dataset.direction =\n          event.currentTarget.dataset.direction === \"horizontal\"\n            ? \"vertical\"\n            : \"horizontal\";\n\n        event.currentTarget.lastElementChild.innerText =\n          event.currentTarget.dataset.direction;\n      });\n      menuElements.push(\n        this.makeElement(\"div\", \"ship-info-container\", shipViewEl, shipInfoEl)\n      );\n    }\n    const shipsMenuEl = this.makeElement(\"div\", \"ships-menu\", ...menuElements);\n    return shipsMenuEl;\n  }\n  static makeShipMenuImgs(length, direction) {\n    // const imgs = BoardRenderer.shipParts;\n    // const imgVertical = []\n    // const imgHorizontal = [BoardRenderer.shipParts.horizontalStart,BoardRenderer.shipParts]\n    document.documentElement.style.setProperty(\n      \"--max-ship-size\",\n      Game.SHIP_MAX_SIZE\n    );\n    const containerEl = renderUtil.makeElement(\"div\", \"ship-parts-view\");\n    const grid = [];\n    for (let i = 0; i < length; i++) {\n      const part = new Image();\n      if (i === 0) part.src = BoardRenderer.shipParts[direction + \"Start\"];\n      else if (i === length - 1)\n        part.src = BoardRenderer.shipParts[direction + \"End\"];\n      else part.src = BoardRenderer.shipParts[direction + \"Middle\"];\n      containerEl.append(part);\n    }\n    return containerEl;\n  }\n}\n// export class UI(){\n\n// }\n","import Game from \"./game.js\";\nimport \"./style.css\";\nimport { BoardRenderer, Render } from \"./render.js\";\n\nconst mainContainer = document.querySelector(\"body\");\n\n// mainContainer.append(currentPlayerBoard.init(10, 10, \"board-container\"));\n// mainContainer.append(enemyPlayerBoard.init(10, 10, \"board-container\"));\nRender.gameStartScreen();\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","length","i","test","Error","replace","p","Ship","constructor","undefined","Number","isInteger","hit","isSunk","setDirection","direction","getDirection","Gameboard","missedShots","attacksReceived","coordinates","Map","splitColumnRow","stringCoordinates","column","row","substring","clearGameboard","value","returnVal","name","TypeError","coordinate","has","getCoordinate","get","updateCoordinate","setCoordinate","cause","newCoordinates","set","toString","placeShip","ship","coordinatesBackup","message","console","error","JSON","stringify","currentLen","receiveAttack","concat","includes","allSunk","size","Array","from","values","every","getRandomCoordinate","copyMissedShots","push","copyReceivedAttacks","codeUnit","charCodeAt","String","fromCharCode","parseInt","Player","gameboard","type","playerType","Logger","buildLoggerEl","getLogger","createElement","logContainer","classList","add","logMessage","playerName","spanEl","dataset","textContent","insertBefore","firstChild","logAttack","currPlayer","targetPlayer","boolHit","sunk","logStatus","enemyPlayer","sunkShips","dealtAttacks","missedHits","Game","static","SHIPS_TYPES","SHIP_MAX_SIZE","maxSize","start","mode","currentStage","players","player1","player2","currentPlayer","playerSetup","coordArray","allPlayersReady","switchPlayer","isPlayerReady","playerMove","attackCoordinates","waitTime","getEnemyPlayer","logger","getCurrentPlayer","isGameover","computerPlayerMove","generateRandomCoordinate","randomRow","Math","floor","random","gameover","some","player","finalStatus","enemy","filter","shipsSunk","Set","status","missedShotsReceived","getWinner","winner","element","getCurrentStage","populatePredetermined","predeterminedCoord","coord","populateGameboard","avaiableShips","shipSize","randomDirection","uniqueShipsInstances","cellsOccupied","reduce","sum","curr","MAX_SHIPS","DragAndDrop","dragstartEvent","shipName","shipLength","dataTransfer","setData","target","nextSibling","dragendHandler","dropEffect","parentElement","remove","log","dropEventHandler","event","preventDefault","col","shipLen","getData","shipDirection","updateBoard","err","dragoverEventHandler","BoardRenderer","rows","columns","className","renderedBoard","grouped","verticalMiddle","verticalStart","verticalEnd","horizontalStart","horizontalEnd","horizontalMiddle","init","preloadImgs","Object","shipParts","forEach","imgSrc","Image","cells","cell","isLabel","boardContainer","renderUtil","makeElement","highlightBoard","bool","getRenderedBoard","initListener","addEventListener","amIEnemy","groupCoordinatesByInstance","allyView","enemyView","revealBoard","gameboardInstance","playerStatus","loopBoard","missEl","replaceChildren","hitEl","renderShip","clickBoardEvent","callback","children","handleEvent","nextRenderPhase","removeEventListener","setTimeout","Render","nextScreen","switchingPlayerScreen","TIME_FOR_HIT_FEEDBACK","call","coordinatesByShips","instance","cellCoordinate","groupedCoord","shipInstance","shipCoordinatesArr","part","partImg","coordinatesOccupiedByShip","indexOf","result","body","querySelector","statusNav","mainContainer","domBoards","setHeader","title","cachedDom","pastMovesList","gameStartScreen","onePlayerBtn","twoPlayersBtn","updateCachedBoards","playerSetupScreen","board","setupDone","shipsDiv","shipsMenuEl","makeShipsMenu","populateBtn","doneBtn","clearBtn","querySelectorAll","append","nextScreenFun","time","Promise","resolve","switching","playerMoveScreen","playerBoard","computerBoard","player1Board","player2Board","boardContainers","makeBoardContainers","enemyBoard","gameOverScreen","childs","myEl","board1HeaderInfo","board2HeaderInfo","board1InfoEl","board2InfoEl","menuElements","shipViewEl","makeShipMenuImgs","draggable","shipInfoEl","currentTarget","lastElementChild","innerText","documentElement","style","setProperty","containerEl"],"sourceRoot":""}