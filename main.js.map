{"version":3,"file":"main.js","mappings":"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","sources":["webpack://battleship-project/webpack/bootstrap","webpack://battleship-project/webpack/runtime/global","webpack://battleship-project/webpack/runtime/publicPath","webpack://battleship-project/./src/ship.js","webpack://battleship-project/./src/gameboard.js","webpack://battleship-project/./src/player.js","webpack://battleship-project/./src/logger.js","webpack://battleship-project/./src/game.js","webpack://battleship-project/./src/drag_drop.js","webpack://battleship-project/./src/board_renderer.js","webpack://battleship-project/./src/render.js","webpack://battleship-project/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export default class Ship {\n  #timesHit = 0;\n  #sunk = false;\n  #direction;\n  constructor(length) {\n    if (length === undefined || Number.isInteger(length) === false)\n      throw new Error(\"Lenght must be provided\");\n    this.length = length;\n  }\n  hit() {\n    this.#timesHit++;\n  }\n  isSunk() {\n    return this.#timesHit >= this.length;\n  }\n  setDirection(direction) {\n    this.#direction = direction;\n  }\n  getDirection() {\n    return this.#direction;\n  }\n}\n","import Ship from \"./ship\";\n\nexport default class Gameboard {\n  //missed shots coordinate are not zero indexed\n  missedShots = [];\n  attacksReceived = [];\n  //TODO change to board instead of coordinates to avoid confusion\n  coordinates;\n\n  constructor() {\n    this.coordinates = new Map();\n  }\n  static splitColumnRow(stringCoordinates) {\n    const [column, row] = [\n      stringCoordinates[0],\n      stringCoordinates.substring(1),\n    ];\n    return [column, row];\n  }\n  clearGameboard() {\n    //this is not pure\n    this.coordinates = this.#clear(this.coordinates);\n    this.missedShots = this.#clear(this.missedShots);\n    this.attacksReceived = this.#clear(this.attacksReceived);\n  }\n  //violating open/closed principle, but the other options take a long time to implement, is not time effective\n  #clear(value) {\n    let returnVal;\n    switch (value.constructor.name) {\n      case \"Array\":\n        returnVal = [];\n        break;\n      case \"Object\":\n        returnVal = {};\n        break;\n      case \"Map\":\n        //should I clear or return a new map ?\n        returnVal = new Map();\n        break;\n      default:\n        throw new TypeError(\"Value should be an array or an object literal\");\n    }\n    return returnVal;\n  }\n  #isCoordinateOccupied(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.has(coordinate);\n  }\n  getCoordinate(column, row) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(`Invalid coordinate at ${(column, row)}`);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.get(coordinate);\n  }\n  updateCoordinate(column, row, value) {\n    throw new Error(\"Not implemented\");\n  }\n  setCoordinate(column, row, value) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(\"Invalid coordinate\", {\n        cause: { column: column, row: row },\n      });\n    if (this.#isCoordinateOccupied(column, row) === true) {\n      throw new Error(\n        \"Coordinate already taken, to overwrite use updateCoordinate\",\n        {\n          cause: { column: column, row: row },\n        }\n      );\n    }\n    //shallow copy the map\n    const newCoordinates = new Map(this.coordinates);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    newCoordinates.set(coordinate, value);\n    this.coordinates = newCoordinates;\n  }\n  #toBoardCoordinates(column, row) {\n    const coordinate = column + row.toString();\n    return coordinate;\n  }\n  //it actually states that placeShip should make a new instance of ship, but how is the player going to decide which ship it is?\n  placeShip(column, row, length, direction = \"horizontal\") {\n    if (direction !== \"horizontal\" && direction !== \"vertical\")\n      throw new Error(\"Invalid direction: should be horizontal or vertical\");\n    const ship = new Ship(length);\n    let currentLen = 1;\n    const coordinatesBackup = this.coordinates;\n    try {\n      this.setCoordinate(column, row, ship);\n      ship.setDirection(direction);\n      this.#spreadShip(column, row, ship, direction, length);\n    } catch (e) {\n      //TODO implement a decent error handler\n      if (\n        e.message === \"Invalid coordinate\" ||\n        e.message === \"Coordinate already taken\"\n      )\n        //would be good if I could get which coordinates got this error\n        // console.error(`Failed at ${JSON.stringify(e.cause)}, ${e.message}`);\n        this.coordinates = coordinatesBackup;\n      throw new Error(`${e.message} at ${e.cause.column}${e.cause.row}`);\n    }\n  }\n  #spreadShip(column, row, ship, direction, length) {\n    let currentLen = 1;\n    //ship.length was causing the test not to work because it is an empty mock, not a mock implementation\n    while (currentLen < length) {\n      if (direction === \"horizontal\") {\n        column = this.#increaseHorizontal(column);\n      } else {\n        row = this.#increaseVertical(row);\n      }\n      currentLen++;\n      this.setCoordinate(column, row, ship);\n    }\n  }\n\n  receiveAttack(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    const ship = this.getCoordinate(column, row);\n    const receivedHits = this.attacksReceived.concat(this.missedShots);\n    if (receivedHits.includes(coordinate) === true)\n      throw new Error(\n        `Unable to attack: coordinate has already been hit at ${column}${row}`\n      );\n    else if (ship instanceof Ship) {\n      ship.hit();\n      this.#recordAttack(column, row);\n      return true;\n    }\n    this.#recordMiss(column, row);\n    return false;\n  }\n  allSunk() {\n    if (this.coordinates.size < 1) {\n      return false;\n    }\n    return Array.from(this.coordinates.values()).every((ship) => {\n      return ship.isSunk() === true;\n    });\n  }\n  //TODO: How do I write a test for this?\n  static getRandomCoordinate() {}\n  //not pure\n  #recordMiss(column, row) {\n    const copyMissedShots = [...this.missedShots];\n    copyMissedShots.push(this.#toBoardCoordinates(column, row));\n    this.missedShots = copyMissedShots;\n  }\n  #recordAttack(column, row) {\n    const copyReceivedAttacks = [...this.attacksReceived];\n    copyReceivedAttacks.push(this.#toBoardCoordinates(column, row));\n    this.attacksReceived = copyReceivedAttacks;\n  }\n  #isCoordinateValid(column, row) {\n    //use regex here\n    if (\n      this.#isRowValid(row) === true &&\n      this.#isColumnValid(column) === true\n    ) {\n      return true;\n    }\n    return false;\n  }\n  #isRowValid(row) {\n    if (row > 10 || row < 1) {\n      return false;\n    }\n    return true;\n  }\n  #isColumnValid(column) {\n    const regex = /[A-J]/;\n    return regex.test(column);\n  }\n  #increaseHorizontal(column) {\n    const codeUnit = column.charCodeAt(0);\n    const newColumn = String.fromCharCode(codeUnit + 1);\n    return newColumn;\n  }\n  #increaseVertical(row) {\n    return Number.parseInt(row) + 1;\n  }\n}\n","import Gameboard from \"./gameboard\";\n\nexport default class Player {\n  #type = null;\n  name;\n  gameboard;\n  constructor(type, name) {\n    this.gameboard = new Gameboard();\n    this.name = name;\n    if (type) this.type = type;\n  }\n  set type(playerType) {\n    if (playerType !== \"real\" && playerType !== \"computer\")\n      throw new TypeError(\"Playertype should be computer or real\");\n    this.#type = playerType;\n  }\n  get type() {\n    return this.#type;\n  }\n}\n","import \"./logger.css\";\nexport default class Logger {\n  #hitMessage = \"hit\";\n  #missMessage = \"missed\";\n  #sunkMessage = \"sunk\";\n  #element;\n  constructor() {\n    this.#element = this.buildLoggerEl();\n  }\n  getLogger() {\n    return this.#element;\n  }\n  buildLoggerEl() {\n    const logHeader = document.createElement(\"div\");\n    const logContainer = document.createElement(\"div\");\n    // logHeader.classList.add(\"log-header\");\n    logContainer.classList.add(\"log-container\");\n    // logHeader.append(logContainer);\n    return logContainer;\n  }\n  //   setAttackMessage(message=\"hit\"){\n  //     return message\n  //   }\n  //   setMissMessage(message)\n  logMessage(message, type, playerName) {\n    const spanEl = document.createElement(\"span\");\n    spanEl.classList.add(\"log-message\");\n    spanEl.classList.add(`log-${type}`);\n    spanEl.dataset.playerName = playerName ? playerName : \"\";\n    spanEl.textContent = message;\n    this.getLogger().insertBefore(spanEl, this.getLogger().firstChild);\n  }\n  logAttack(currPlayer, targetPlayer, coordinates, boolHit, sunk = false) {\n    // const messageEl = document.createElement(\"span\");\n    // messageEl.classList.add(\"log-message\");\n    let message = `${currPlayer} attacked coordinates ${coordinates} and `;\n    if (boolHit === true) {\n      message += `successfully ${this.#hitMessage} ${\n        sunk === true ? \"and sunk\" : \"\"\n      } ${targetPlayer}'s Ship`;\n    } else {\n      message += `${this.#missMessage} ${targetPlayer}'s Ships`;\n    }\n    this.logMessage(message, \"attack\", currPlayer);\n    // messageEl.textContent = message;\n    // this.getLogger().appendChild(messageEl);\n  }\n  //TODO\n  logStatus(currPlayer, { enemyPlayer, sunkShips, dealtAttacks, missedHits }) {\n    let message = `${currPlayer.name} Status: \\n\n    Enemy ships sunk: ${sunkShips} \\n\n    Attacks Dealt: ${dealtAttacks}\\n\n    Missed Hits: ${missedHits}\\n\n    `;\n    this.logMessage(message, \"status\");\n  }\n}\n","// import Gameboard from \"./gameboard\";\nimport Player from \"./player\";\nimport Logger from \"./logger.js\";\nimport Gameboard from \"./gameboard.js\";\n//this will serve as the mediator ?\nexport default class Game {\n  static players = [];\n  static stages = [\"start\", \"playerSetup\", \"playerMove\", \"gameOver\"];\n  static gameover = false;\n  static logger = new Logger();\n\n  //first item will be the current player\n  static player1;\n  static player2;\n  static currentPlayer;\n  static currentStage;\n\n  static SHIPS_TYPES = [\n    { name: \"Carrier\", length: 5 },\n    { name: \"Battleship\", length: 4 },\n    { name: \"Destroyer\", length: 3 },\n    { name: \"Submarine\", length: 3 },\n    { name: \"Patrol Boat\", length: 2 },\n  ];\n\n  static MAX_SHIPS = this.SHIPS_TYPES.length;\n  //shouldnt I manage the phases here ?\n  static get SHIP_MAX_SIZE() {\n    let maxSize = 0;\n    for (let { length } of Game.SHIPS_TYPES) {\n      maxSize = length > maxSize ? length : maxSize;\n    }\n    return maxSize;\n  }\n  static start(mode = 1) {\n    //populate the gameboard with predetermined coordinates\n    this.currentStage = \"start\";\n    if (mode === 1) {\n      Game.players.push(\n        new Player(\"real\", \"Player\"),\n        new Player(\"computer\", \"Computer\")\n      );\n    } else {\n      Game.players.push(\n        new Player(\"real\", \"Player 1\"),\n        new Player(\"real\", \"Player 2\")\n      );\n    }\n    [this.player1, this.player2] = this.players;\n    Game.currentPlayer = this.player1;\n    const nextStage = \"playerSetup\";\n\n    return (this.currentStage = nextStage);\n  }\n\n  //stages''\n  //This is not doing what it should\n  //it should get the positions on the board and place ships there\n\n  static playerSetup(coordArray) {\n    //should I call the next phase here?\n    this.currentStage = \"playerSetup\";\n    if (Game.allPlayersReady() === true) {\n      this.currentStage = \"playerMove\";\n      Game.switchPlayer();\n      return this.currentStage;\n    }\n\n    const currentPlayer = Game.currentPlayer;\n    //TODO get coordinates that event handler got\n    // for (const coord of coordArray) {\n    //   currentPlayer.gameboard.placeShip(...coord);\n    // }\n\n    //if player placed all ships correctly he can proceed to the next phase\n    if (Game.isPlayerReady(currentPlayer) === true) {\n      Game.switchPlayer();\n      return this.currentStage;\n    } else {\n      throw new Error(\"Player is not ready\");\n    }\n  }\n\n  //I should decide if it gets column,row or coordinates\n  //I can use the Gameboard.splitColumnRow here to get the column and row\n  static playerMove(attackCoordinates, waitTime = 0) {\n    const [column, row] = [\n      attackCoordinates[0],\n      attackCoordinates.substring(1),\n    ];\n    this.currentStage = \"playerMove\";\n    const enemyPlayer = this.getEnemyPlayer();\n    const hit = enemyPlayer.gameboard.receiveAttack(column, row);\n    const sunk =\n      hit === false\n        ? false\n        : enemyPlayer.gameboard.getCoordinate(column, row).isSunk();\n\n    this.logger.logAttack(\n      this.getCurrentPlayer().name,\n      this.getEnemyPlayer().name,\n      attackCoordinates,\n      hit,\n      sunk\n    );\n\n    if (this.isGameover()) {\n      this.currentStage = \"gameOver\";\n\n      return this.currentStage;\n    }\n    //insert gameovercheck\n    Game.switchPlayer();\n    return this.currentStage;\n  }\n  static computerPlayerMove() {\n    let nextStage;\n    let coordinates;\n    while (true) {\n      try {\n        coordinates = Game.generateRandomCoordinate();\n        return Game.playerMove(coordinates);\n      } catch (error) {\n        // console.error(`tried at ${coordinates}, regenerating`);\n        if (error.message.includes(\"coordinate has already been hit\") === false)\n          throw error;\n      }\n    }\n  }\n  //should I move this to gameboard ?\n  static generateRandomCoordinate() {\n    const COLUMNS = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"];\n    const MINCOORDINATE = 1;\n    const MAXCOORDINATE = 10;\n    const randomRow = Math.floor(\n      Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n    );\n    //-1 at the end because arrays are zero indexed\n    const randomCol =\n      COLUMNS[\n        Math.floor(\n          Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n        ) - 1\n      ];\n\n    return randomCol.concat(randomRow);\n  }\n  //not pure\n  static isGameover() {\n    //TODO im checking only for the enemy player, should I check for all just to make sure?\n    this.gameover = this.players.some(\n      (player) => player.gameboard.allSunk() === true\n    );\n\n    return this.gameover;\n    // const enemyPlayer = Game.getEnemyPlayer();\n    // return enemyPlayer.gameboard.allSunk();\n  }\n  static finalStatus(player) {\n    const [enemy] = this.players.filter((p) => p !== player);\n    const gameboard = enemy.gameboard;\n    const ships = Array.from(new Set(gameboard.coordinates.values()));\n    const shipsSunk = ships.filter((ship) => ship.isSunk() === true);\n    const status = {\n      player: player,\n      attacksReceived: gameboard.attacksReceived.length,\n      missedShotsReceived: gameboard.missedShots.length,\n      sunkShips: shipsSunk.length,\n    };\n    this.logger.logStatus(player, {\n      enemyPlayer: enemy,\n      sunkShips: status.sunkShips,\n      dealtAttacks: status.attacksReceived,\n      missedHits: status.missedShotsReceived,\n    });\n  }\n  static getWinner() {\n    if (this.gameover === false) return;\n    const [winner] = this.players.filter(\n      (player) => player.gameboard.allSunk() === false\n    );\n    return winner;\n  }\n  static getEnemyPlayer() {\n    const [enemyPlayer] = this.players.filter(\n      (element) => element !== Game.getCurrentPlayer()\n    );\n\n    return enemyPlayer;\n  }\n  static getCurrentPlayer() {\n    return Game.currentPlayer;\n  }\n  static getCurrentStage() {\n    return Game.currentStage;\n  }\n  static switchPlayer() {\n    let oldCurrPlayer = this.currentPlayer;\n    this.currentPlayer =\n      this.currentPlayer === this.player1 ? this.player2 : this.player1;\n  }\n  static populatePredetermined(player, coordArray) {\n    player.gameboard.clearGameboard();\n    const predeterminedCoord = [\n      [\"A\", 1, 5, \"horizontal\"],\n      [\"D\", 5, 3, \"vertical\"],\n      [\"A\", 3, 4, \"vertical\"],\n      [\"A\", 8, 3, \"horizontal\"],\n      [\"A\", 10, 2, \"horizontal\"],\n    ];\n    for (const coord of predeterminedCoord) {\n      Game.getCurrentPlayer().gameboard.placeShip(...coord);\n    }\n  }\n  static populateGameboard(player) {\n    player.gameboard.clearGameboard();\n    const avaiableShips = Game.SHIPS_TYPES;\n    for (let ship of avaiableShips) {\n      let shipSize = ship.length;\n      while (true) {\n        let coordinates;\n        let randomDirection;\n        let column;\n        let row;\n        try {\n          coordinates = Game.generateRandomCoordinate();\n          randomDirection =\n            Math.floor(Math.random() * 2) === 0 ? \"vertical\" : \"horizontal\";\n          [column, row] = Gameboard.splitColumnRow(coordinates);\n          player.gameboard.placeShip(column, row, shipSize, randomDirection);\n          break;\n        } catch (error) {\n          if (\n            error.message.includes(\"Coordinate already taken\") ||\n            error.message.includes(\"Invalid coordinate\")\n          ) {\n            // console.error(\n            //   `tried to place at ${coordinates}, separated ${column},${row}, regenerating`\n            // );\n          } else {\n            throw error;\n          }\n        }\n      }\n    }\n  }\n  static isPlayerReady(player) {\n    const uniqueShipsInstances = new Set(player.gameboard.coordinates.values());\n    const cellsOccupied = this.SHIPS_TYPES.reduce((sum, curr) => {\n      return curr.length + sum;\n    }, 0);\n    return (\n      uniqueShipsInstances.size === this.MAX_SHIPS &&\n      player.gameboard.coordinates.size === cellsOccupied\n    );\n  }\n  static allPlayersReady() {\n    return this.players.every((player) => this.isPlayerReady(player) === true);\n  }\n}\n//TODO LET GAME HANDLE GAME PHASES\n","export default class DragAndDrop {\n  static #dropStatus = \"\";\n  static dragstartEvent(shipName, shipLength) {\n    DragAndDrop.#dropStatus = \"\";\n\n    return function dragEventHandler(e) {\n      e.dataTransfer.setData(\"shipName\", shipName);\n      e.dataTransfer.setData(\"shipLength\", shipLength);\n      e.dataTransfer.setData(\n        \"shipDirection\",\n        e.target.nextSibling.dataset.direction\n      );\n\n      // e.dataTransfer.setDragImage(e.target, 40, 40);\n    };\n  }\n  static dragendHandler(e) {\n    if (\n      e.dataTransfer.dropEffect === \"move\" &&\n      DragAndDrop.#dropStatus === \"Success\"\n    ) {\n      e.target.parentElement.remove();\n      console.log(\"dragend success\");\n    } else {\n      console.log(\"dragend failed\");\n    }\n  }\n\n  static dropEventHandler(event) {\n    //TODO can I put the remove event listener here ?\n\n    event.preventDefault();\n\n    const [col, row] = [\n      event.target.dataset.coordinates[0],\n      event.target.dataset.coordinates.substring(1),\n    ];\n    const shipLen = Number.parseInt(event.dataTransfer.getData(\"shipLength\"));\n    const shipName = event.dataTransfer.getData(\"shipName\");\n    const shipDirection = event.dataTransfer.getData(\"shipDirection\");\n    //TOFIX: if ship was already placed, position should be updated instead of placing another copy\n    //FIXED: WHEN PASSING A DIRECTION OTHER THAN HORIZONTAL A 1 GETS ADDED\n    //TOFIX: When failing placing the ship, shouldnt interrupt the whole program anymore\n    try {\n      this.player.gameboard.placeShip(col, row, shipLen, shipDirection);\n      this.updateBoard();\n    } catch (err) {\n      if (\n        err.message.includes(\"Invalid coordinate\") ||\n        err.message.includes(\"Coordinate already taken\")\n      ) {\n        //this is not going to work, dropEffect cant be changed on drop\n        DragAndDrop.#dropStatus = \"Fail\";\n        event.dataTransfer.dropEffect = \"none\";\n        return;\n      }\n      throw err;\n      //notify logger\n    }\n    DragAndDrop.#dropStatus = \"Success\";\n    // event.dataTransfer.dropEffect = \"move\";\n\n    //I can either make it unable to drag after placing or\n    //implement something that removes the ship\n\n    //Dragend fires an event at the object that was being dragged, i can use it to remove the drag\n    //or I can make an array that controls\n  }\n  static dragoverEventHandler(event) {\n    if (event.target.dataset.coordinates === undefined) {\n      console.log(\"dragover aborting\");\n      return;\n    }\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n  }\n}\n","import DragAndDrop from \"./drag_drop\";\nimport Game from \"./game\";\nimport { Render } from \"./render\";\nimport { renderUtil } from \"./render\";\nimport hitImg from \"./assets/hit.png\";\nimport missImg from \"./assets/miss.png\";\nimport shipImg from \"./assets/ship.png\";\nimport shipEndImg from \"./assets/shipEnd.png\";\nimport shipEndVerticalImg from \"./assets/shipEndVertical.png\";\nimport shipStartImg from \"./assets/shipStart.png\";\nimport shipStartVerticalImg from \"./assets/shipStartVertical.png\";\nimport shipMiddleImg from \"./assets/shipMiddle.png\";\nimport shipMiddleVerticalImg from \"./assets/shipMiddleVertical.png\";\n\nexport class BoardRenderer {\n  rows;\n  columns;\n  className;\n  renderedBoard;\n  player;\n  grouped = null;\n  static TIME_FOR_HIT_FEEDBACK = 1200;\n  static shipParts = {\n    verticalMiddle: shipMiddleVerticalImg,\n    verticalStart: shipStartVerticalImg,\n    verticalEnd: shipEndVerticalImg,\n    horizontalStart: shipStartImg,\n    horizontalEnd: shipEndImg,\n    horizontalMiddle: shipMiddleImg,\n  };\n  constructor(player, rows = 10, columns = 10, className = \"board-container\") {\n    this.rows = rows;\n    this.columns = columns;\n    this.className = className;\n    this.player = player;\n    this.init(rows, columns, className);\n    BoardRenderer.preloadImgs();\n  }\n  static preloadImgs() {\n    Object.values(this.shipParts).forEach((imgSrc) => {\n      const img = new Image();\n      img.src = imgSrc;\n    });\n  }\n  init() {\n    const rows = this.rows;\n    const columns = this.columns;\n    const className = this.className;\n    const cellNumber = columns * rows;\n    const alphabet = \"ABCDEFGHIJ\";\n    const cells = [];\n    //row 0 is the label for the columns\n    //column 0 is the label for the rows\n\n    for (let row = 0; row <= rows; row++) {\n      for (let column = 0; column <= columns; column++) {\n        const cell = document.createElement(\"div\");\n        cell.dataset.column = column;\n        cell.dataset.row = row;\n        cell.dataset.isLabel = true;\n        if (row > 0 && column > 0) {\n          //strings are zero indexed but the column is not\n          cell.dataset.isLabel = false;\n          cell.dataset.coordinates = `${alphabet[column - 1]}${row}`;\n        }\n\n        cells.push(cell);\n      }\n    }\n\n    const boardContainer = renderUtil.makeElement(\"div\", className, ...cells);\n    boardContainer.dataset.player = this.player.name;\n    this.renderedBoard = boardContainer;\n\n    // return boardContainer;\n  }\n  highlightBoard(bool) {\n    if (bool === true) this.renderedBoard.classList.add(\"highlight\");\n    else this.renderedBoard.classList.remove(\"highlight\");\n  }\n  getRenderedBoard() {\n    return this.renderedBoard;\n  }\n  initListener() {\n    this.getRenderedBoard().addEventListener(\"click\", this);\n  }\n  amIEnemy() {\n    return Game.getEnemyPlayer() === this.player;\n  }\n  updateBoard() {\n    this.grouped = this.groupCoordinatesByInstance();\n    if (this.amIEnemy() === true) {\n      //need to see my ships and enemy players hits\n      //I am the current player\n\n      this.enemyView();\n      return;\n    } else {\n      //if im the enemy player, the current player needs to see\n      //my attacks received, missed hits\n      this.allyView();\n    }\n  }\n  revealBoard() {\n    this.allyView();\n  }\n  //REFACTOR\n  enemyView(gameboardInstance) {\n    this.renderedBoard.dataset.playerStatus = \"enemy\";\n    this.highlightBoard(true);\n    const missedHits = this.player.gameboard.missedShots;\n    const attacksReceived = this.player.gameboard.attacksReceived;\n\n    this.loopBoard((cell) => {\n      if (missedHits.includes(cell.dataset.coordinates)) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (attacksReceived.includes(cell.dataset.coordinates)) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n  allyView(gameboardInstance) {\n    //!!\n\n    this.renderedBoard.dataset.playerStatus = \"ally\";\n    this.highlightBoard(false);\n    //TODO can make the loop make three arrays and then we assign the content to those depending on type of array\n\n    this.loopBoard((cell) => {\n      //if gameboard coordinates matches missed shots or attacks received or coordinates\n      //change text content(img later) to match according to what it is\n      //board is updated whenever places ship\n      //REFACTOR\n      //TODO separate the stylying for each cell status\n      if (\n        this.player.gameboard.attacksReceived.includes(cell.dataset.coordinates)\n      ) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else if (\n        this.player.gameboard.missedShots.includes(cell.dataset.coordinates)\n      ) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (\n        this.player.gameboard.coordinates.has(cell.dataset.coordinates)\n      ) {\n        cell.replaceChildren(this.renderShip(cell.dataset.coordinates));\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n\n  clickBoardEvent(event) {\n    if (this.amIEnemy() === true) {\n      return event.target.dataset.coordinates;\n    }\n  }\n  loopBoard(callback) {\n    for (let cell of this.renderedBoard.children) {\n      if (cell.dataset.isLabel === \"true\") {\n        continue;\n      }\n\n      callback(cell);\n    }\n  }\n  handleEvent(event) {\n    if (event.target.dataset.coordinates === undefined) return;\n    //Refactor give the event to each handler properly\n    if (event.type === \"drop\") this.dropEventHandler(event);\n    if (event.type === \"dragover\") this.dragoverEventHandler(event);\n    if (event.type !== \"click\") return;\n    if (Game.getCurrentStage() === \"playerMove\" && this.amIEnemy() === true) {\n      const attackCoordinates = this.clickBoardEvent(event);\n      const nextRenderPhase = Game.playerMove(attackCoordinates);\n\n      this.getRenderedBoard().removeEventListener(\"click\", this);\n      // this.updateBoard();\n      //Because playerMove changed the active player, update board will detect the current board as an ally instead of enemy, so we override it to be enemyView\n      //THIS ALSO INTRODUCES A BUG, IN WHICH IF YOU CLICK ON YOUR BOARD BEFORE THE TIME YOU CAN ATTACK IT\n      //Fixed by disabling pointer events and by placing listener on the enemy board ONLY and removing it later\n      this.enemyView();\n\n      setTimeout(() => {\n        if (this.player.type === \"computer\") {\n          Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n        } else {\n          Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"]);\n        }\n      }, BoardRenderer.TIME_FOR_HIT_FEEDBACK);\n    }\n  }\n\n  //make this fun reference the other fun\n  dropEventHandler(event) {\n    if (Game.getCurrentStage() !== \"playerSetup\") return;\n    DragAndDrop.dropEventHandler.call(this, event);\n  }\n\n  dragoverEventHandler(event) {\n    DragAndDrop.dragoverEventHandler.call(this, event);\n  }\n  groupCoordinatesByInstance() {\n    //I only need to run this after setup, then I can use the stored value and apply a tag for hit\n    const gameboard = this.player.gameboard;\n    const coordinatesByShips = new Map();\n    //grouping by instances\n    for (let [coordinate, instance] of gameboard.coordinates) {\n      if (coordinatesByShips.has(instance) === true) {\n        coordinatesByShips.get(instance).push(coordinate);\n      } else {\n        coordinatesByShips.set(instance, [coordinate]);\n      }\n    }\n    //Sort so its either A1 A2 A3(vertical) or A1 B1 C1(horizontal)\n    //its already sorted\n    // coordinatesByShips.forEach((val, key) => val.sort());\n\n    return coordinatesByShips;\n  }\n  renderShip(cellCoordinate) {\n    const groupedCoord = this.grouped;\n    const coordinates = this.player.gameboard.coordinates;\n    //I should only loop through the cells that have a ship, or, cells that are in the coordinates array\n\n    if (coordinates.has(cellCoordinate)) {\n      const shipInstance = coordinates.get(cellCoordinate);\n      //all the coordinates that ship occupies\n      const shipCoordinatesArr = groupedCoord.get(shipInstance);\n      //which part is this? Start, middle or end ?\n      const part = this.#assignShipParts(\n        shipCoordinatesArr,\n        shipInstance.getDirection(),\n        cellCoordinate\n      );\n      const partImg = new Image();\n      partImg.src = part;\n      return partImg;\n\n      //DONE change this to only receive the coordinates and decide which part is\n      // - should return the part\n      // - should not loop\n    }\n  }\n\n  //decides if its a middle, start or end part\n  #assignShipParts(coordinatesOccupiedByShip, shipDirection, coordinates) {\n    const part = coordinatesOccupiedByShip.indexOf(coordinates);\n    const result = coordinatesOccupiedByShip.length - part;\n    // return this.shipParts[shipDirection + result]\n\n    if (result === 1) return BoardRenderer.shipParts[shipDirection + \"End\"];\n    else if (result === coordinatesOccupiedByShip.length)\n      return BoardRenderer.shipParts[shipDirection + \"Start\"];\n    else {\n      return BoardRenderer.shipParts[shipDirection + \"Middle\"];\n    }\n  }\n}\n","import \"./board.css\";\nimport Game from \"./game.js\";\nimport { BoardRenderer } from \"./board_renderer.js\";\nimport DragAndDrop from \"./drag_drop.js\";\nexport class Render {\n  static cachedDom = {\n    body: document.querySelector(\"body\"),\n    statusNav: document.querySelector(\".header\"),\n    mainContainer: document.querySelector(\".main-container\"),\n    domBoards: [],\n    logger: null,\n  };\n\n  static setHeader(title) {\n    this.cachedDom.statusNav.textContent = title;\n  }\n  static pastMovesList() {}\n\n  static gameStartScreen() {\n    //TODO memoize\n    const onePlayerBtn = document.createElement(\"button\");\n    const twoPlayersBtn = document.createElement(\"button\");\n    onePlayerBtn.classList.add(\"one-player-button\");\n    twoPlayersBtn.classList.add(\"two-player-button\");\n    onePlayerBtn.textContent = \"One player Mode\";\n    twoPlayersBtn.textContent = \"Two players Mode\";\n    //TODO: No need to repeat, clean this up later\n    onePlayerBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(1);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    twoPlayersBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(2);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    Render.cachedDom.mainContainer.replaceChildren(onePlayerBtn, twoPlayersBtn);\n    Render.cachedDom.mainContainer.classList.add(\"game-start-phase\");\n    this.cachedDom.statusNav.textContent = \"BattleShip\";\n  }\n  static updateCachedBoards() {\n    this.cachedDom.domBoards.forEach((element) => element.updateBoard());\n    return this.cachedDom.domBoards;\n  }\n  //BUG: stage isnt changing to playerSetup\n  static playerSetupScreen(currentPlayer) {\n    this.cachedDom.mainContainer.classList.add(\"player-setup-phase\");\n    const board = new BoardRenderer(Game.getCurrentPlayer());\n\n    if (Game.getCurrentPlayer().type === \"computer\") {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      setupDone();\n      return;\n    }\n    Render.setHeader(`${Game.getCurrentPlayer().name}'s Turn - Setup Phase`);\n    const shipsDiv = renderUtil.makeElement(\"div\", \"ship-placement-container\");\n    const shipsMenuEl = renderUtil.makeShipsMenu(Game.SHIPS_TYPES);\n    const populateBtn = document.createElement(\"button\");\n    const doneBtn = document.createElement(\"button\");\n    const clearBtn = document.createElement(\"button\");\n    clearBtn.textContent = \"Reset\";\n    populateBtn.textContent = `Populate ${Game.getCurrentPlayer().name} board`;\n    doneBtn.textContent = `Done`;\n\n    clearBtn.addEventListener(\"click\", (event) => {\n      Game.currentPlayer.gameboard.clearGameboard();\n      board.updateBoard();\n      this.playerSetupScreen(Game.getCurrentPlayer());\n    });\n    populateBtn.addEventListener(\"click\", () => {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      shipsDiv\n        .querySelectorAll(\".ship-info-container\")\n        .forEach((part) => part.remove());\n      board.updateBoard();\n    });\n    doneBtn.addEventListener(\"click\", setupDone);\n    function setupDone(event) {\n      //fixed\n\n      const nextRenderPhase = Game.playerSetup();\n      Render.cachedDom.domBoards.push(board);\n      Render.cachedDom.mainContainer.classList.remove(\"player-setup-phase\");\n\n      // Render.cachedDom.renderedBoards.push(board);\n      Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"], 500);\n    }\n\n    shipsDiv.append(shipsMenuEl, clearBtn, populateBtn, doneBtn);\n    board.getRenderedBoard().addEventListener(\"drop\", board);\n    board.getRenderedBoard().addEventListener(\"dragover\", board);\n    this.cachedDom.mainContainer.replaceChildren(\n      shipsDiv,\n      board.getRenderedBoard()\n    );\n  }\n\n  //should I place update board here on the switching playerScreen  ?\n  //TODO this is wrong? Is there a need to return promise here?\n  static async nextScreen(nextScreenFun, time = 0) {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        // Game.switchPlayer();\n        nextScreenFun.call(this);\n      }, time);\n    });\n  }\n  static async switchingPlayerScreen(nextScreenFun, time = 500) {\n    const switching = document.createElement(\"p\");\n    switching.textContent = \"Switching players, please hold . . . \";\n    this.cachedDom.statusNav.textContent = `Switching from ${\n      Game.getEnemyPlayer().name\n    } to ${Game.getCurrentPlayer().name}`;\n\n    Render.cachedDom.mainContainer.replaceChildren(switching);\n    await Render.nextScreen(nextScreenFun, time);\n\n    //set a timer to change the screen and board to the other player\n  }\n\n  //REFACTOR clean up this is messy\n  static playerMoveScreen() {\n    this.setHeader(`${Game.getCurrentPlayer().name}'s Turn`);\n\n    //TODO next: Decide also if the two boards are going to be p1 board and p2 board or enemy and currentplayer board\n    if (this.cachedDom.logger === null) {\n      const logger = Game.logger;\n      this.cachedDom.logger = logger;\n      this.cachedDom.body.append(logger.getLogger());\n    }\n    this.cachedDom.mainContainer.classList.add(\"player-move-phase\");\n\n    if (Game.currentPlayer.type === \"computer\") {\n      let playerBoard;\n      let computerBoard;\n      this.cachedDom.domBoards.forEach((board) => {\n        if (board.player.type === \"computer\") computerBoard = board;\n        else playerBoard = board;\n      });\n\n      playerBoard.highlightBoard(true);\n      computerBoard.getRenderedBoard().classList.add(\"dim\");\n      const nextRenderPhase = Game.computerPlayerMove();\n      setTimeout(() => {\n        playerBoard.highlightBoard(false);\n        computerBoard.getRenderedBoard().classList.remove(\"dim\");\n        Render[nextRenderPhase + \"Screen\"]();\n      }, BoardRenderer.TIME_FOR_HIT_FEEDBACK);\n\n      return;\n    }\n    //DONE stop making new boards\n    //DONE make board in the same position so theres no changing around each round\n    const [player1Board, player2Board] = this.updateCachedBoards();\n\n    //Refactor: Change this to a function that handles rendering the board altogether so I can reuse it on gameover scene\n    //I can also just cache this screen and reuse it\n    const boardContainers = renderUtil.makeBoardContainers(\n      player1Board,\n      player2Board\n    );\n\n    this.cachedDom.mainContainer.replaceChildren(boardContainers);\n    //REFACTOR change to handleEvent on the board\n    //listener is on the board\n    const [enemyBoard] = this.cachedDom.domBoards.filter(\n      (board) => board.amIEnemy() === true\n    );\n    enemyBoard.getRenderedBoard().addEventListener(\"click\", enemyBoard);\n    //TODO implement gameover check\n  }\n  static gameOverScreen() {\n    this.cachedDom.mainContainer.classList.remove(\"player-move-phase\");\n    const [player1Board, player2Board] = this.cachedDom.domBoards;\n    player1Board.revealBoard();\n    player2Board.revealBoard();\n\n    Render.cachedDom.mainContainer.replaceChildren(\n      player1Board.getRenderedBoard(),\n      player2Board.getRenderedBoard()\n    );\n    Game.finalStatus(Game.getCurrentPlayer());\n    Game.finalStatus(Game.getEnemyPlayer());\n    Render.setHeader(`${Game.getWinner().name} is the winner`);\n  }\n}\n//TODO change to upperCase\nexport class renderUtil {\n  static makeElement(element, className, ...childs) {\n    const myEl = document.createElement(element);\n    myEl.classList.add(className);\n    if (childs) {\n      myEl.append(...childs);\n    }\n    return myEl;\n  }\n  //todo\n  static makeBoardContainers(player1Board, player2Board) {\n    const boardContainers = renderUtil.makeElement(\"div\", \"board-containers\");\n    const board1HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    const board2HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    board1HeaderInfo.textContent = player1Board.player.name;\n    board2HeaderInfo.textContent = player2Board.player.name;\n    const board1InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board1HeaderInfo,\n      player1Board.getRenderedBoard()\n    );\n    const board2InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board2HeaderInfo,\n      player2Board.getRenderedBoard()\n    );\n    boardContainers.replaceChildren(board1InfoEl, board2InfoEl);\n    return boardContainers;\n  }\n\n  //TODO move this to drag and drop ?\n  static makeShipsMenu(SHIPS_TYPES) {\n    const menuElements = [];\n    for (let { name, length } of SHIPS_TYPES) {\n      // const shipViewEl = this.makeElement(\"div\", \"ship-view\");\n      let direction = \"horizontal\";\n      const shipViewEl = this.makeShipMenuImgs(length, direction);\n      //TODO finish draggable implementation\n      shipViewEl.draggable = true;\n\n      // shipViewEl.addEventListener(\"dragend\", (event) => {\n      //   const data = event.dataTransfer.getData(\"text\");\n      // });\n      const shipName = this.makeElement(\"p\", \"ship-name\");\n      const shipLength = this.makeElement(\"p\", \"ship-length\");\n      const shipDirection = this.makeElement(\"p\", \"ship-direction\");\n      shipName.textContent = name;\n      shipLength.textContent = length;\n      shipDirection.textContent = direction;\n      shipViewEl.addEventListener(\n        \"dragstart\",\n        DragAndDrop.dragstartEvent(name, length)\n      );\n      shipViewEl.addEventListener(\"dragend\", DragAndDrop.dragendHandler);\n\n      const shipInfoEl = this.makeElement(\n        \"div\",\n        \"ship-info\",\n        shipName,\n        shipLength,\n        shipDirection\n      );\n      shipInfoEl.dataset.direction = direction;\n      shipInfoEl.addEventListener(\"click\", (event) => {\n        event.currentTarget.dataset.direction =\n          event.currentTarget.dataset.direction === \"horizontal\"\n            ? \"vertical\"\n            : \"horizontal\";\n\n        event.currentTarget.lastElementChild.innerText =\n          event.currentTarget.dataset.direction;\n      });\n      menuElements.push(\n        this.makeElement(\"div\", \"ship-info-container\", shipViewEl, shipInfoEl)\n      );\n    }\n    const shipsMenuEl = this.makeElement(\"div\", \"ships-menu\", ...menuElements);\n    return shipsMenuEl;\n  }\n  static makeShipMenuImgs(length, direction) {\n    // const imgs = BoardRenderer.shipParts;\n    // const imgVertical = []\n    // const imgHorizontal = [BoardRenderer.shipParts.horizontalStart,BoardRenderer.shipParts]\n    document.documentElement.style.setProperty(\n      \"--max-ship-size\",\n      Game.SHIP_MAX_SIZE\n    );\n    const containerEl = renderUtil.makeElement(\"div\", \"ship-parts-view\");\n    const grid = [];\n    for (let i = 0; i < length; i++) {\n      const part = new Image();\n      if (i === 0) part.src = BoardRenderer.shipParts[direction + \"Start\"];\n      else if (i === length - 1)\n        part.src = BoardRenderer.shipParts[direction + \"End\"];\n      else part.src = BoardRenderer.shipParts[direction + \"Middle\"];\n      containerEl.append(part);\n    }\n    return containerEl;\n  }\n}\n// export class UI(){\n\n// }\n","import Game from \"./game.js\";\nimport \"./style.css\";\nimport { BoardRenderer, Render } from \"./render.js\";\n\nconst mainContainer = document.querySelector(\"body\");\n\n// mainContainer.append(currentPlayerBoard.init(10, 10, \"board-container\"));\n// mainContainer.append(enemyPlayerBoard.init(10, 10, \"board-container\"));\nRender.gameStartScreen();\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","length","i","test","Error","replace","p","Ship","constructor","undefined","Number","isInteger","hit","isSunk","setDirection","direction","getDirection","Gameboard","missedShots","attacksReceived","coordinates","Map","splitColumnRow","stringCoordinates","column","row","substring","clearGameboard","value","returnVal","name","TypeError","coordinate","has","getCoordinate","get","updateCoordinate","setCoordinate","cause","newCoordinates","set","toString","placeShip","ship","coordinatesBackup","message","currentLen","receiveAttack","concat","includes","allSunk","size","Array","from","values","every","getRandomCoordinate","copyMissedShots","push","copyReceivedAttacks","codeUnit","charCodeAt","String","fromCharCode","parseInt","Player","gameboard","type","playerType","Logger","buildLoggerEl","getLogger","createElement","logContainer","classList","add","logMessage","playerName","spanEl","dataset","textContent","insertBefore","firstChild","logAttack","currPlayer","targetPlayer","boolHit","sunk","logStatus","enemyPlayer","sunkShips","dealtAttacks","missedHits","Game","static","SHIPS_TYPES","SHIP_MAX_SIZE","maxSize","start","mode","currentStage","players","player1","player2","currentPlayer","playerSetup","coordArray","allPlayersReady","switchPlayer","isPlayerReady","playerMove","attackCoordinates","waitTime","getEnemyPlayer","logger","getCurrentPlayer","isGameover","computerPlayerMove","generateRandomCoordinate","error","randomRow","Math","floor","random","gameover","some","player","finalStatus","enemy","filter","shipsSunk","Set","status","missedShotsReceived","getWinner","winner","element","getCurrentStage","populatePredetermined","predeterminedCoord","coord","populateGameboard","avaiableShips","shipSize","randomDirection","uniqueShipsInstances","cellsOccupied","reduce","sum","curr","MAX_SHIPS","DragAndDrop","dragstartEvent","shipName","shipLength","dataTransfer","setData","target","nextSibling","dragendHandler","dropEffect","parentElement","remove","console","log","dropEventHandler","event","preventDefault","col","shipLen","getData","shipDirection","updateBoard","err","dragoverEventHandler","BoardRenderer","rows","columns","className","renderedBoard","grouped","verticalMiddle","verticalStart","verticalEnd","horizontalStart","horizontalEnd","horizontalMiddle","init","preloadImgs","Object","shipParts","forEach","imgSrc","Image","cells","cell","isLabel","boardContainer","renderUtil","makeElement","highlightBoard","bool","getRenderedBoard","initListener","addEventListener","amIEnemy","groupCoordinatesByInstance","allyView","enemyView","revealBoard","gameboardInstance","playerStatus","loopBoard","missEl","replaceChildren","hitEl","renderShip","clickBoardEvent","callback","children","handleEvent","nextRenderPhase","removeEventListener","setTimeout","Render","nextScreen","switchingPlayerScreen","TIME_FOR_HIT_FEEDBACK","call","coordinatesByShips","instance","cellCoordinate","groupedCoord","shipInstance","shipCoordinatesArr","part","partImg","coordinatesOccupiedByShip","indexOf","result","body","querySelector","statusNav","mainContainer","domBoards","setHeader","title","cachedDom","pastMovesList","gameStartScreen","onePlayerBtn","twoPlayersBtn","updateCachedBoards","playerSetupScreen","board","setupDone","shipsDiv","shipsMenuEl","makeShipsMenu","populateBtn","doneBtn","clearBtn","querySelectorAll","append","nextScreenFun","time","Promise","resolve","switching","playerMoveScreen","playerBoard","computerBoard","player1Board","player2Board","boardContainers","makeBoardContainers","enemyBoard","gameOverScreen","childs","myEl","board1HeaderInfo","board2HeaderInfo","board1InfoEl","board2InfoEl","menuElements","shipViewEl","makeShipMenuImgs","draggable","shipInfoEl","currentTarget","lastElementChild","innerText","documentElement","style","setProperty","containerEl"],"sourceRoot":""}