{"version":3,"file":"main.js","mappings":"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","sources":["webpack://battleship-project/webpack/bootstrap","webpack://battleship-project/webpack/runtime/global","webpack://battleship-project/webpack/runtime/publicPath","webpack://battleship-project/./src/ship.js","webpack://battleship-project/./src/gameboard.js","webpack://battleship-project/./src/player.js","webpack://battleship-project/./src/logger.js","webpack://battleship-project/./src/game.js","webpack://battleship-project/./src/drag_drop.js","webpack://battleship-project/./src/board_renderer.js","webpack://battleship-project/./src/render.js","webpack://battleship-project/./src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export default class Ship {\n  #timesHit = 0;\n  #sunk = false;\n  #direction;\n  constructor(length) {\n    if (length === undefined || Number.isInteger(length) === false)\n      throw new Error(\"Lenght must be provided\");\n    this.length = length;\n  }\n  hit() {\n    this.#timesHit++;\n  }\n  isSunk() {\n    return this.#timesHit >= this.length;\n  }\n  setDirection(direction) {\n    this.#direction = direction;\n  }\n  getDirection() {\n    return this.#direction;\n  }\n}\n","import Ship from \"./ship\";\n\nexport default class Gameboard {\n  //missed shots coordinate are not zero indexed\n  missedShots = [];\n  attacksReceived = [];\n  //TODO change to board instead of coordinates to avoid confusion\n  coordinates;\n\n  constructor() {\n    this.coordinates = new Map();\n  }\n  static splitColumnRow(stringCoordinates) {\n    const [column, row] = [\n      stringCoordinates[0],\n      stringCoordinates.substring(1),\n    ];\n    return [column, row];\n  }\n  clearGameboard() {\n    //this is not pure\n    this.coordinates = this.#clear(this.coordinates);\n    this.missedShots = this.#clear(this.missedShots);\n    this.attacksReceived = this.#clear(this.attacksReceived);\n  }\n  //violating open/closed principle, but the other options take a long time to implement, is not time effective\n  #clear(value) {\n    let returnVal;\n    switch (value.constructor.name) {\n      case \"Array\":\n        returnVal = [];\n        break;\n      case \"Object\":\n        returnVal = {};\n        break;\n      case \"Map\":\n        //should I clear or return a new map ?\n        returnVal = new Map();\n        break;\n      default:\n        throw new TypeError(\"Value should be an array or an object literal\");\n    }\n    return returnVal;\n  }\n  #isCoordinateOccupied(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.has(coordinate);\n  }\n  getCoordinate(column, row) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(`Invalid coordinate at ${(column, row)}`);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    return this.coordinates.get(coordinate);\n  }\n  updateCoordinate(column, row, value) {\n    throw new Error(\"Not implemented\");\n  }\n  setCoordinate(column, row, value) {\n    if (this.#isCoordinateValid(column, row) === false)\n      throw new Error(\"Invalid coordinate\", {\n        cause: { column: column, row: row },\n      });\n    if (this.#isCoordinateOccupied(column, row) === true) {\n      throw new Error(\n        \"Coordinate already taken, to overwrite use updateCoordinate\",\n        {\n          cause: { column: column, row: row },\n        }\n      );\n    }\n    //shallow copy the map\n    const newCoordinates = new Map(this.coordinates);\n    const coordinate = this.#toBoardCoordinates(column, row);\n    newCoordinates.set(coordinate, value);\n    this.coordinates = newCoordinates;\n  }\n  #toBoardCoordinates(column, row) {\n    const coordinate = column + row.toString();\n    return coordinate;\n  }\n  //it actually states that placeShip should make a new instance of ship, but how is the player going to decide which ship it is?\n  placeShip(column, row, length, direction = \"horizontal\") {\n    if (direction !== \"horizontal\" && direction !== \"vertical\")\n      throw new Error(\"Invalid direction: should be horizontal or vertical\");\n    const ship = new Ship(length);\n    let currentLen = 1;\n    const coordinatesBackup = this.coordinates;\n    try {\n      this.setCoordinate(column, row, ship);\n      ship.setDirection(direction);\n      this.#spreadShip(column, row, ship, direction, length);\n    } catch (e) {\n      // console.log(e);\n\n      //TODO implement a decent error handler\n      if (\n        e.message === \"Invalid coordinate\" ||\n        e.message === \"Coordinate already taken\"\n      )\n        //would be good if I could get which coordinates got this error\n        console.error(`Failed at ${JSON.stringify(e.cause)}, ${e.message}`);\n      this.coordinates = coordinatesBackup;\n      throw new Error(`${e.message} at ${e.cause.column}${e.cause.row}`);\n    }\n  }\n  #spreadShip(column, row, ship, direction, length) {\n    let currentLen = 1;\n    //ship.length was causing the test not to work because it is an empty mock, not a mock implementation\n    while (currentLen < length) {\n      if (direction === \"horizontal\") {\n        column = this.#increaseHorizontal(column);\n      } else {\n        row = this.#increaseVertical(row);\n      }\n      currentLen++;\n      this.setCoordinate(column, row, ship);\n    }\n  }\n\n  receiveAttack(column, row) {\n    const coordinate = this.#toBoardCoordinates(column, row);\n    const ship = this.getCoordinate(column, row);\n    const receivedHits = this.attacksReceived.concat(this.missedShots);\n    if (receivedHits.includes(coordinate) === true)\n      throw new Error(\n        `Unable to attack: coordinate has already been hit at ${column}${row}`\n      );\n    else if (ship instanceof Ship) {\n      ship.hit();\n      this.#recordAttack(column, row);\n      return true;\n    }\n    this.#recordMiss(column, row);\n    return false;\n  }\n  allSunk() {\n    if (this.coordinates.size < 1) {\n      console.log(\"there are no ships\");\n      return false;\n    }\n    return Array.from(this.coordinates.values()).every((ship) => {\n      return ship.isSunk() === true;\n    });\n  }\n  //TODO: How do I write a test for this?\n  static getRandomCoordinate() {}\n  //not pure\n  #recordMiss(column, row) {\n    const copyMissedShots = [...this.missedShots];\n    copyMissedShots.push(this.#toBoardCoordinates(column, row));\n    this.missedShots = copyMissedShots;\n  }\n  #recordAttack(column, row) {\n    const copyReceivedAttacks = [...this.attacksReceived];\n    copyReceivedAttacks.push(this.#toBoardCoordinates(column, row));\n    this.attacksReceived = copyReceivedAttacks;\n  }\n  #isCoordinateValid(column, row) {\n    //use regex here\n    if (\n      this.#isRowValid(row) === true &&\n      this.#isColumnValid(column) === true\n    ) {\n      return true;\n    }\n    return false;\n  }\n  #isRowValid(row) {\n    if (row > 10 || row < 1) {\n      return false;\n    }\n    return true;\n  }\n  #isColumnValid(column) {\n    const regex = /[A-J]/;\n    return regex.test(column);\n  }\n  #increaseHorizontal(column) {\n    const codeUnit = column.charCodeAt(0);\n    const newColumn = String.fromCharCode(codeUnit + 1);\n    return newColumn;\n  }\n  #increaseVertical(row) {\n    return Number.parseInt(row) + 1;\n  }\n}\n","import Gameboard from \"./gameboard\";\n\nexport default class Player {\n  #type = null;\n  name;\n  gameboard;\n  constructor(type, name) {\n    this.gameboard = new Gameboard();\n    this.name = name;\n    if (type) this.type = type;\n  }\n  set type(playerType) {\n    if (playerType !== \"real\" && playerType !== \"computer\")\n      throw new TypeError(\"Playertype should be computer or real\");\n    this.#type = playerType;\n  }\n  get type() {\n    return this.#type;\n  }\n}\n","import \"./logger.css\";\nexport default class Logger {\n  #hitMessage = \"hit\";\n  #missMessage = \"missed\";\n  #sunkMessage = \"sunk\";\n  #element;\n  constructor() {\n    this.#element = this.buildLoggerEl();\n  }\n  getLogger() {\n    return this.#element;\n  }\n  buildLoggerEl() {\n    const logHeader = document.createElement(\"div\");\n    const logContainer = document.createElement(\"div\");\n    // logHeader.classList.add(\"log-header\");\n    logContainer.classList.add(\"log-container\");\n    // logHeader.append(logContainer);\n    return logContainer;\n  }\n  //   setAttackMessage(message=\"hit\"){\n  //     return message\n  //   }\n  //   setMissMessage(message)\n  logMessage(message, type, playerName) {\n    const spanEl = document.createElement(\"span\");\n    spanEl.classList.add(\"log-message\");\n    spanEl.classList.add(`log-${type}`);\n    spanEl.dataset.playerName = playerName ? playerName : \"\";\n    spanEl.textContent = message;\n    this.getLogger().insertBefore(spanEl, this.getLogger().firstChild);\n  }\n  logAttack(currPlayer, targetPlayer, coordinates, boolHit, sunk = false) {\n    // const messageEl = document.createElement(\"span\");\n    // messageEl.classList.add(\"log-message\");\n    let message = `${currPlayer} attacked coordinates ${coordinates} and `;\n    if (boolHit === true) {\n      message += `successfully ${this.#hitMessage} ${\n        sunk === true ? \"and sunk\" : \"\"\n      } ${targetPlayer}'s Ship`;\n    } else {\n      message += `${this.#missMessage} ${targetPlayer}'s Ships`;\n    }\n    this.logMessage(message, \"attack\", currPlayer);\n    // messageEl.textContent = message;\n    // this.getLogger().appendChild(messageEl);\n  }\n  //TODO\n  logStatus(currPlayer, { enemyPlayer, sunkShips, dealtAttacks, missedHits }) {\n    let message = `${currPlayer.name} Status: \\n\n    Enemy ships sunk: ${sunkShips} \\n\n    Attacks Dealt: ${dealtAttacks}\\n\n    Missed Hits: ${missedHits}\\n\n    `;\n    this.logMessage(message, \"status\");\n  }\n}\n","// import Gameboard from \"./gameboard\";\nimport Player from \"./player\";\nimport Logger from \"./logger.js\";\nimport Gameboard from \"./gameboard.js\";\n//this will serve as the mediator ?\nexport default class Game {\n  static players = [];\n  static stages = [\"start\", \"playerSetup\", \"playerMove\", \"gameOver\"];\n  static gameover = false;\n  static logger = new Logger();\n\n  //first item will be the current player\n  static player1;\n  static player2;\n  static currentPlayer;\n  static currentStage;\n\n  static SHIPS_TYPES = [\n    { name: \"Carrier\", length: 5 },\n    { name: \"Battleship\", length: 4 },\n    { name: \"Destroyer\", length: 3 },\n    { name: \"Submarine\", length: 3 },\n    { name: \"Patrol Boat\", length: 2 },\n  ];\n\n  static MAX_SHIPS = this.SHIPS_TYPES.length;\n  //shouldnt I manage the phases here ?\n  static get SHIP_MAX_SIZE() {\n    let maxSize = 0;\n    for (let { length } of Game.SHIPS_TYPES) {\n      maxSize = length > maxSize ? length : maxSize;\n    }\n    return maxSize;\n  }\n  static start(mode = 1) {\n    //populate the gameboard with predetermined coordinates\n    console.log(\"start game\");\n    this.currentStage = \"start\";\n    if (mode === 1) {\n      Game.players.push(\n        new Player(\"real\", \"Player\"),\n        new Player(\"computer\", \"Computer\")\n      );\n    } else {\n      Game.players.push(\n        new Player(\"real\", \"Player 1\"),\n        new Player(\"real\", \"Player 2\")\n      );\n    }\n    [this.player1, this.player2] = this.players;\n    Game.currentPlayer = this.player1;\n    const nextStage = \"playerSetup\";\n\n    return (this.currentStage = nextStage);\n  }\n\n  //stages''\n  //This is not doing what it should\n  //it should get the positions on the board and place ships there\n\n  static playerSetup(coordArray) {\n    //should I call the next phase here?\n    console.log(\"Setting up\", Game.getCurrentPlayer());\n    this.currentStage = \"playerSetup\";\n    if (Game.allPlayersReady() === true) {\n      this.currentStage = \"playerMove\";\n      Game.switchPlayer();\n      return this.currentStage;\n    }\n\n    const currentPlayer = Game.currentPlayer;\n    //TODO get coordinates that event handler got\n    // for (const coord of coordArray) {\n    //   currentPlayer.gameboard.placeShip(...coord);\n    // }\n\n    //if player placed all ships correctly he can proceed to the next phase\n    if (Game.isPlayerReady(currentPlayer) === true) {\n      Game.switchPlayer();\n      return this.currentStage;\n    } else {\n      throw new Error(\"Player is not ready\");\n    }\n  }\n\n  //I should decide if it gets column,row or coordinates\n  //I can use the Gameboard.splitColumnRow here to get the column and row\n  static playerMove(attackCoordinates, waitTime = 0) {\n    const [column, row] = [\n      attackCoordinates[0],\n      attackCoordinates.substring(1),\n    ];\n    this.currentStage = \"playerMove\";\n    const enemyPlayer = this.getEnemyPlayer();\n    const hit = enemyPlayer.gameboard.receiveAttack(column, row);\n    const sunk =\n      hit === false\n        ? false\n        : enemyPlayer.gameboard.getCoordinate(column, row).isSunk();\n\n    this.logger.logAttack(\n      this.getCurrentPlayer().name,\n      this.getEnemyPlayer().name,\n      attackCoordinates,\n      hit,\n      sunk\n    );\n    console.log(\n      `${enemyPlayer.name} attack received at ${attackCoordinates}, did it hit ? : ${hit}`\n    );\n    if (this.isGameover()) {\n      this.currentStage = \"gameOver\";\n\n      return this.currentStage;\n    }\n    //insert gameovercheck\n    Game.switchPlayer();\n    return this.currentStage;\n  }\n  static computerPlayerMove() {\n    let nextStage;\n    let coordinates;\n    while (true) {\n      try {\n        coordinates = Game.generateRandomCoordinate();\n        return Game.playerMove(coordinates);\n      } catch (error) {\n        console.error(`tried at ${coordinates}, regenerating`);\n        if (error.message.includes(\"coordinate has already been hit\") === false)\n          throw error;\n      }\n    }\n  }\n  //should I move this to gameboard ?\n  static generateRandomCoordinate() {\n    const COLUMNS = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"];\n    const MINCOORDINATE = 1;\n    const MAXCOORDINATE = 10;\n    const randomRow = Math.floor(\n      Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n    );\n    //-1 at the end because arrays are zero indexed\n    const randomCol =\n      COLUMNS[\n        Math.floor(\n          Math.random() * (MAXCOORDINATE - MINCOORDINATE + 1) + MINCOORDINATE\n        ) - 1\n      ];\n\n    return randomCol.concat(randomRow);\n  }\n  //not pure\n  static isGameover() {\n    //TODO im checking only for the enemy player, should I check for all just to make sure?\n    this.gameover = this.players.some(\n      (player) => player.gameboard.allSunk() === true\n    );\n\n    return this.gameover;\n    // const enemyPlayer = Game.getEnemyPlayer();\n    // return enemyPlayer.gameboard.allSunk();\n  }\n  static finalStatus(player) {\n    const [enemy] = this.players.filter((p) => p !== player);\n    const gameboard = enemy.gameboard;\n    const ships = Array.from(new Set(gameboard.coordinates.values()));\n    const shipsSunk = ships.filter((ship) => ship.isSunk() === true);\n    console.log(shipsSunk);\n    const status = {\n      player: player,\n      attacksReceived: gameboard.attacksReceived.length,\n      missedShotsReceived: gameboard.missedShots.length,\n      sunkShips: shipsSunk.length,\n    };\n    this.logger.logStatus(player, {\n      enemyPlayer: enemy,\n      sunkShips: status.sunkShips,\n      dealtAttacks: status.attacksReceived,\n      missedHits: status.missedShotsReceived,\n    });\n  }\n  static getWinner() {\n    if (this.gameover === false) return;\n    const [winner] = this.players.filter(\n      (player) => player.gameboard.allSunk() === false\n    );\n    return winner;\n  }\n  static getEnemyPlayer() {\n    const [enemyPlayer] = this.players.filter(\n      (element) => element !== Game.getCurrentPlayer()\n    );\n\n    return enemyPlayer;\n  }\n  static getCurrentPlayer() {\n    return Game.currentPlayer;\n  }\n  static getCurrentStage() {\n    return Game.currentStage;\n  }\n  static switchPlayer() {\n    let oldCurrPlayer = this.currentPlayer;\n    this.currentPlayer =\n      this.currentPlayer === this.player1 ? this.player2 : this.player1;\n    console.log(\n      `switched from ${oldCurrPlayer.name} to ${this.currentPlayer.name}`\n    );\n  }\n  static populatePredetermined(player, coordArray) {\n    console.log(\"populating player\", player.name);\n    player.gameboard.clearGameboard();\n    const predeterminedCoord = [\n      [\"A\", 1, 5, \"horizontal\"],\n      [\"D\", 5, 3, \"vertical\"],\n      [\"A\", 3, 4, \"vertical\"],\n      [\"A\", 8, 3, \"horizontal\"],\n      [\"A\", 10, 2, \"horizontal\"],\n    ];\n    for (const coord of predeterminedCoord) {\n      Game.getCurrentPlayer().gameboard.placeShip(...coord);\n    }\n  }\n  static populateGameboard(player) {\n    player.gameboard.clearGameboard();\n    const avaiableShips = Game.SHIPS_TYPES;\n    for (let ship of avaiableShips) {\n      let shipSize = ship.length;\n      while (true) {\n        let coordinates;\n        let randomDirection;\n        let column;\n        let row;\n        try {\n          coordinates = Game.generateRandomCoordinate();\n          randomDirection =\n            Math.floor(Math.random() * 2) === 0 ? \"vertical\" : \"horizontal\";\n          [column, row] = Gameboard.splitColumnRow(coordinates);\n          player.gameboard.placeShip(column, row, shipSize, randomDirection);\n          break;\n        } catch (error) {\n          if (\n            error.message.includes(\"Coordinate already taken\") ||\n            error.message.includes(\"Invalid coordinate\")\n          ) {\n            console.error(\n              `tried to place at ${coordinates}, separated ${column},${row}, regenerating`\n            );\n          } else {\n            throw error;\n          }\n        }\n      }\n    }\n  }\n  static isPlayerReady(player) {\n    const uniqueShipsInstances = new Set(player.gameboard.coordinates.values());\n    const cellsOccupied = this.SHIPS_TYPES.reduce((sum, curr) => {\n      return curr.length + sum;\n    }, 0);\n    console.log(cellsOccupied);\n    return (\n      uniqueShipsInstances.size === this.MAX_SHIPS &&\n      player.gameboard.coordinates.size === cellsOccupied\n    );\n  }\n  static allPlayersReady() {\n    return this.players.every((player) => this.isPlayerReady(player) === true);\n  }\n}\n//TODO LET GAME HANDLE GAME PHASES\n","export default class DragAndDrop {\n  static #dropStatus = \"\";\n  static dragstartEvent(shipName, shipLength) {\n    DragAndDrop.#dropStatus = \"\";\n\n    return function dragEventHandler(e) {\n      e.dataTransfer.setData(\"shipName\", shipName);\n      e.dataTransfer.setData(\"shipLength\", shipLength);\n      e.dataTransfer.setData(\n        \"shipDirection\",\n        e.target.nextSibling.dataset.direction\n      );\n\n      // e.dataTransfer.setDragImage(e.target, 40, 40);\n      console.log(\"dragstart\");\n      console.log(e.dataTransfer.dropEffect);\n    };\n  }\n  static dragendHandler(e) {\n    if (\n      e.dataTransfer.dropEffect === \"move\" &&\n      DragAndDrop.#dropStatus === \"Success\"\n    ) {\n      // e.target.draggable = false;\n      e.target.parentElement.remove();\n      console.log(\"dragend success\");\n    } else {\n      console.log(\"dragend failed\");\n    }\n    console.log(\"dragend\");\n    console.log(\"drop effect \" + e.dataTransfer.dropEffect);\n  }\n\n  static dropEventHandler(event) {\n    //TODO can I put the remove event listener here ?\n\n    // if (event.target.dataset.coordinates === undefined) {\n    //   console.log(\"aborted\");\n    //   return;\n    // }\n    event.preventDefault();\n    console.log(this);\n    console.log(event.target);\n    const [col, row] = [\n      event.target.dataset.coordinates[0],\n      event.target.dataset.coordinates.substring(1),\n    ];\n    const shipLen = Number.parseInt(event.dataTransfer.getData(\"shipLength\"));\n    const shipName = event.dataTransfer.getData(\"shipName\");\n    const shipDirection = event.dataTransfer.getData(\"shipDirection\");\n    console.log(shipLen, shipName, shipDirection);\n    //TOFIX: if ship was already placed, position should be updated instead of placing another copy\n    console.log(col, row, shipLen, shipDirection);\n    //FIXED: WHEN PASSING A DIRECTION OTHER THAN HORIZONTAL A 1 GETS ADDED\n    //TOFIX: When failing placing the ship, shouldnt interrupt the whole program anymore\n    try {\n      this.player.gameboard.placeShip(col, row, shipLen, shipDirection);\n      this.updateBoard();\n    } catch (err) {\n      if (\n        err.message.includes(\"Invalid coordinate\") ||\n        err.message.includes(\"Coordinate already taken\")\n      ) {\n        //this is not going to work, dropEffect cant be changed on drop\n        DragAndDrop.#dropStatus = \"Fail\";\n        event.dataTransfer.dropEffect = \"none\";\n        return;\n      }\n      throw err;\n      //notify logger\n    }\n    DragAndDrop.#dropStatus = \"Success\";\n    // event.dataTransfer.dropEffect = \"move\";\n\n    //I can either make it unable to drag after placing or\n    //implement something that removes the ship\n\n    //Dragend fires an event at the object that was being dragged, i can use it to remove the drag\n    //or I can make an array that controls\n  }\n  static dragoverEventHandler(event) {\n    if (event.target.dataset.coordinates === undefined) {\n      console.log(\"dragover aborting\");\n      return;\n    }\n    event.preventDefault();\n    event.dataTransfer.dropEffect = \"move\";\n    console.log(event.dataTransfer.dropEffect);\n  }\n  // static dragLeaveEventHandler(event) {\n  //   event.preventDefault();\n  //   console.log(\"dragleave\");\n  //   event.target.dataset.dragover = \"false\";\n  // }\n}\n","import DragAndDrop from \"./drag_drop\";\nimport Game from \"./game\";\nimport { Render } from \"./render\";\nimport { renderUtil } from \"./render\";\nimport hitImg from \"./assets/hit.png\";\nimport missImg from \"./assets/miss.png\";\nimport shipImg from \"./assets/ship.png\";\nimport shipEndImg from \"./assets/shipEnd.png\";\nimport shipEndVerticalImg from \"./assets/shipEndVertical.png\";\nimport shipStartImg from \"./assets/shipStart.png\";\nimport shipStartVerticalImg from \"./assets/shipStartVertical.png\";\nimport shipMiddleImg from \"./assets/shipMiddle.png\";\nimport shipMiddleVerticalImg from \"./assets/shipMiddleVertical.png\";\n\nexport class BoardRenderer {\n  rows;\n  columns;\n  className;\n  renderedBoard;\n  player;\n  grouped = null;\n  static TIME_FOR_HIT_FEEDBACK = 2000;\n  static shipParts = {\n    verticalMiddle: shipMiddleVerticalImg,\n    verticalStart: shipStartVerticalImg,\n    verticalEnd: shipEndVerticalImg,\n    horizontalStart: shipStartImg,\n    horizontalEnd: shipEndImg,\n    horizontalMiddle: shipMiddleImg,\n  };\n  constructor(player, rows = 10, columns = 10, className = \"board-container\") {\n    this.rows = rows;\n    this.columns = columns;\n    this.className = className;\n    this.player = player;\n    this.init(rows, columns, className);\n    BoardRenderer.preloadImgs();\n  }\n  static preloadImgs() {\n    Object.values(this.shipParts).forEach((imgSrc) => {\n      const img = new Image();\n      img.src = imgSrc;\n    });\n  }\n  init() {\n    const rows = this.rows;\n    const columns = this.columns;\n    const className = this.className;\n    const cellNumber = columns * rows;\n    const alphabet = \"ABCDEFGHIJ\";\n    const cells = [];\n    //row 0 is the label for the columns\n    //column 0 is the label for the rows\n\n    for (let row = 0; row <= rows; row++) {\n      for (let column = 0; column <= columns; column++) {\n        const cell = document.createElement(\"div\");\n        cell.dataset.column = column;\n        cell.dataset.row = row;\n        cell.dataset.isLabel = true;\n        if (row > 0 && column > 0) {\n          //strings are zero indexed but the column is not\n          cell.dataset.isLabel = false;\n          cell.dataset.coordinates = `${alphabet[column - 1]}${row}`;\n        }\n\n        cells.push(cell);\n      }\n    }\n\n    const boardContainer = renderUtil.makeElement(\"div\", className, ...cells);\n\n    boardContainer.dataset.player = this.player.name;\n    // boardContainer.addEventListener(\"click\", this);\n    // const boundEvent = this.clickBoardEvent.bind(this);\n    // boardContainer.addEventListener(\"click\", boundEvent);\n\n    this.renderedBoard = boardContainer;\n    console.log(this.renderedBoard);\n    // return boardContainer;\n  }\n  getRenderedBoard() {\n    return this.renderedBoard;\n  }\n  initListener() {\n    this.getRenderedBoard().addEventListener(\"click\", this);\n  }\n  amIEnemy() {\n    return Game.getEnemyPlayer() === this.player;\n  }\n  updateBoard() {\n    this.grouped = this.groupCoordinatesByInstance();\n    if (this.amIEnemy() === true) {\n      //need to see my ships and enemy players hits\n      //I am the current player\n      console.log(`${this.player.name} is enemy`);\n      this.enemyView();\n      return;\n    } else {\n      //if im the enemy player, the current player needs to see\n      //my attacks received, missed hits\n      console.log(`${this.player.name} is active player`);\n      this.allyView();\n    }\n  }\n  revealBoard() {\n    this.allyView();\n  }\n  //REFACTOR\n  enemyView(gameboardInstance) {\n    this.renderedBoard.dataset.playerStatus = \"enemy\";\n    const missedHits = this.player.gameboard.missedShots;\n    const attacksReceived = this.player.gameboard.attacksReceived;\n\n    this.loopBoard((cell) => {\n      if (missedHits.includes(cell.dataset.coordinates)) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (attacksReceived.includes(cell.dataset.coordinates)) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n  allyView(gameboardInstance) {\n    //!!\n    this.renderedBoard.dataset.playerStatus = \"ally\";\n    //TODO can make the loop make three arrays and then we assign the content to those depending on type of array\n\n    this.loopBoard((cell) => {\n      //if gameboard coordinates matches missed shots or attacks received or coordinates\n      //change text content(img later) to match according to what it is\n      //board is updated whenever places ship\n      //REFACTOR\n      //TODO separate the stylying for each cell status\n      if (\n        this.player.gameboard.attacksReceived.includes(cell.dataset.coordinates)\n      ) {\n        const hitEl = new Image();\n        hitEl.src = hitImg;\n        cell.replaceChildren(hitEl);\n      } else if (\n        this.player.gameboard.missedShots.includes(cell.dataset.coordinates)\n      ) {\n        const missEl = new Image();\n        missEl.src = missImg;\n        cell.replaceChildren(missEl);\n      } else if (\n        this.player.gameboard.coordinates.has(cell.dataset.coordinates)\n      ) {\n        console.log(\"found\");\n        cell.replaceChildren(this.renderShip(cell.dataset.coordinates));\n      } else {\n        cell.replaceChildren();\n      }\n    });\n  }\n\n  clickBoardEvent(event) {\n    if (this.amIEnemy() === true) {\n      return event.target.dataset.coordinates;\n    }\n  }\n  loopBoard(callback) {\n    for (let cell of this.renderedBoard.children) {\n      if (cell.dataset.isLabel === \"true\") {\n        continue;\n      }\n\n      callback(cell);\n    }\n  }\n  handleEvent(event) {\n    console.log(this);\n    console.log(event.type);\n    console.log(event.target);\n    console.log(Game.getCurrentStage());\n    if (event.target.dataset.coordinates === undefined) return;\n    //Refactor give the event to each handler properly\n    console.log(\"here\");\n    if (event.type === \"drop\") this.dropEventHandler(event);\n    if (event.type === \"dragover\") this.dragoverEventHandler(event);\n    if (event.type !== \"click\") return;\n    if (Game.getCurrentStage() === \"playerMove\" && this.amIEnemy() === true) {\n      const attackCoordinates = this.clickBoardEvent(event);\n      const nextRenderPhase = Game.playerMove(attackCoordinates);\n      this.getRenderedBoard().removeEventListener(\"click\", this);\n      // this.updateBoard();\n      //Because playerMove changed the active player, update board will detect the current board as an ally instead of enemy, so we override it to be enemyView\n      //THIS ALSO INTRODUCES A BUG, IN WHICH IF YOU CLICK ON YOUR BOARD BEFORE THE TIME YOU CAN ATTACK IT\n      //Fixed by disabling pointer events and by placing listener on the enemy board ONLY and removing it later\n      this.enemyView();\n      setTimeout(() => {\n        Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"]);\n      }, BoardRenderer.TIME_FOR_HIT_FEEDBACK);\n    }\n  }\n\n  //make this fun reference the other fun\n  dropEventHandler(event) {\n    if (Game.getCurrentStage() !== \"playerSetup\") return;\n    DragAndDrop.dropEventHandler.call(this, event);\n  }\n\n  dragoverEventHandler(event) {\n    DragAndDrop.dragoverEventHandler.call(this, event);\n  }\n  groupCoordinatesByInstance() {\n    //I only need to run this after setup, then I can use the stored value and apply a tag for hit\n    const gameboard = this.player.gameboard;\n    const coordinatesByShips = new Map();\n    //grouping by instances\n    for (let [coordinate, instance] of gameboard.coordinates) {\n      if (coordinatesByShips.has(instance) === true) {\n        coordinatesByShips.get(instance).push(coordinate);\n      } else {\n        coordinatesByShips.set(instance, [coordinate]);\n      }\n    }\n    //Sort so its either A1 A2 A3(vertical) or A1 B1 C1(horizontal)\n    //its already sorted\n    // coordinatesByShips.forEach((val, key) => val.sort());\n\n    console.log(\"coordinatesbySHIPS\");\n    console.log(coordinatesByShips);\n    return coordinatesByShips;\n  }\n  renderShip(cellCoordinate) {\n    const groupedCoord = this.grouped;\n    const coordinates = this.player.gameboard.coordinates;\n    //I should only loop through the cells that have a ship, or, cells that are in the coordinates array\n\n    console.log(cellCoordinate);\n    if (coordinates.has(cellCoordinate)) {\n      const shipInstance = coordinates.get(cellCoordinate);\n      console.log(shipInstance);\n      //all the coordinates that ship occupies\n      const shipCoordinatesArr = groupedCoord.get(shipInstance);\n      //which part is this? Start, middle or end ?\n      const part = this.#assignShipParts(\n        shipCoordinatesArr,\n        shipInstance.getDirection(),\n        cellCoordinate\n      );\n      const partImg = new Image();\n      partImg.src = part;\n      console.log(part);\n      return partImg;\n\n      //DONE change this to only receive the coordinates and decide which part is\n      // - should return the part\n      // - should not loop\n    }\n  }\n\n  //decides if its a middle, start or end part\n  #assignShipParts(coordinatesOccupiedByShip, shipDirection, coordinates) {\n    const part = coordinatesOccupiedByShip.indexOf(coordinates);\n    const result = coordinatesOccupiedByShip.length - part;\n    // return this.shipParts[shipDirection + result]\n\n    if (result === 1) return BoardRenderer.shipParts[shipDirection + \"End\"];\n    else if (result === coordinatesOccupiedByShip.length)\n      return BoardRenderer.shipParts[shipDirection + \"Start\"];\n    else {\n      return BoardRenderer.shipParts[shipDirection + \"Middle\"];\n    }\n  }\n}\n","import \"./board.css\";\nimport Game from \"./game.js\";\nimport { BoardRenderer } from \"./board_renderer.js\";\nimport DragAndDrop from \"./drag_drop.js\";\nexport class Render {\n  static cachedDom = {\n    body: document.querySelector(\"body\"),\n    statusNav: document.querySelector(\".header\"),\n    mainContainer: document.querySelector(\".main-container\"),\n    domBoards: [],\n    logger: null,\n  };\n\n  static setHeader(title) {\n    this.cachedDom.statusNav.textContent = title;\n  }\n  static pastMovesList() {}\n\n  static gameStartScreen() {\n    //TODO memoize\n    console.log(\"game start screen\");\n    const onePlayerBtn = document.createElement(\"button\");\n    const twoPlayersBtn = document.createElement(\"button\");\n    onePlayerBtn.classList.add(\"one-player-button\");\n    twoPlayersBtn.classList.add(\"two-player-button\");\n    onePlayerBtn.textContent = \"One player Mode\";\n    twoPlayersBtn.textContent = \"Two players Mode\";\n    //TODO: No need to repeat, clean this up later\n    onePlayerBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(1);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    twoPlayersBtn.addEventListener(\"click\", (event) => {\n      const nextRenderPhase = Game.start(2);\n      Render.cachedDom.mainContainer.classList.remove(\"game-start-phase\");\n\n      Render.nextScreen(Render[nextRenderPhase + \"Screen\"]);\n    });\n    Render.cachedDom.mainContainer.replaceChildren(onePlayerBtn, twoPlayersBtn);\n    Render.cachedDom.mainContainer.classList.add(\"game-start-phase\");\n    this.cachedDom.statusNav.textContent = \"BattleShip\";\n  }\n  static updateCachedBoards() {\n    this.cachedDom.domBoards.forEach((element) => element.updateBoard());\n    return this.cachedDom.domBoards;\n  }\n  //BUG: stage isnt changing to playerSetup\n  static playerSetupScreen(currentPlayer) {\n    this.cachedDom.mainContainer.classList.add(\"player-setup-phase\");\n    const board = new BoardRenderer(Game.getCurrentPlayer());\n\n    if (Game.getCurrentPlayer().type === \"computer\") {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      setupDone();\n      return;\n    }\n    Render.setHeader(`${Game.getCurrentPlayer().name}'s Turn - Setup Phase`);\n    const shipsDiv = renderUtil.makeElement(\"div\", \"ship-placement-container\");\n    const shipsMenuEl = renderUtil.makeShipsMenu(Game.SHIPS_TYPES);\n    const populateBtn = document.createElement(\"button\");\n    const doneBtn = document.createElement(\"button\");\n    const clearBtn = document.createElement(\"button\");\n    clearBtn.textContent = \"Reset\";\n    populateBtn.textContent = `Populate ${Game.getCurrentPlayer().name} board`;\n    doneBtn.textContent = `Done`;\n\n    clearBtn.addEventListener(\"click\", (event) => {\n      Game.currentPlayer.gameboard.clearGameboard();\n      board.updateBoard();\n      this.playerSetupScreen(Game.getCurrentPlayer());\n    });\n    populateBtn.addEventListener(\"click\", () => {\n      Game.populateGameboard(Game.getCurrentPlayer());\n      shipsDiv\n        .querySelectorAll(\".ship-info-container\")\n        .forEach((part) => part.remove());\n      board.updateBoard();\n    });\n    doneBtn.addEventListener(\"click\", setupDone);\n    function setupDone(event) {\n      //fixed\n\n      const nextRenderPhase = Game.playerSetup();\n      console.log(nextRenderPhase);\n      Render.cachedDom.domBoards.push(board);\n      Render.cachedDom.mainContainer.classList.remove(\"player-setup-phase\");\n\n      // Render.cachedDom.renderedBoards.push(board);\n      Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"], 500);\n    }\n\n    shipsDiv.append(shipsMenuEl, clearBtn, populateBtn, doneBtn);\n    board.getRenderedBoard().addEventListener(\"drop\", board);\n    board.getRenderedBoard().addEventListener(\"dragover\", board);\n    this.cachedDom.mainContainer.replaceChildren(\n      shipsDiv,\n      board.getRenderedBoard()\n    );\n  }\n\n  //should I place update board here on the switching playerScreen  ?\n  static async nextScreen(nextScreenFun, time = 0) {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        // Game.switchPlayer();\n        nextScreenFun.call(this);\n      }, time);\n    });\n  }\n  static async switchingPlayerScreen(nextScreenFun, time = 500) {\n    const switching = document.createElement(\"p\");\n    switching.textContent = \"Switching players, please hold . . . \";\n    this.cachedDom.statusNav.textContent = `Switching from ${\n      Game.getEnemyPlayer().name\n    } to ${Game.getCurrentPlayer().name}`;\n\n    Render.cachedDom.mainContainer.replaceChildren(switching);\n    await Render.nextScreen(nextScreenFun, time);\n\n    //set a timer to change the screen and board to the other player\n  }\n\n  //REFACTOR clean up this is messy\n  static playerMoveScreen() {\n    //TODO next: Decide also if the two boards are going to be p1 board and p2 board or enemy and currentplayer board\n    if (this.cachedDom.logger === null) {\n      const logger = Game.logger;\n      this.cachedDom.logger = logger;\n      this.cachedDom.body.append(logger.getLogger());\n    }\n    this.cachedDom.mainContainer.classList.add(\"player-move-phase\");\n    // document.documentElement.style.setProperty(\n    //   \"--current-player\",\n    //   Game.getCurrentPlayer().name\n    // );\n\n    // console.log(this.cachedDom.domBoards);\n    // console.log(\"player Move Screen\");\n    // console.log(Game.getCurrentStage());\n    if (Game.currentPlayer.type === \"computer\") {\n      const nextRenderPhase = Game.computerPlayerMove();\n      Render.switchingPlayerScreen(Render[nextRenderPhase + \"Screen\"], 0);\n    }\n    //DONE stop making new boards\n    //DONE make board in the same position so theres no changing around each round\n    const [player1Board, player2Board] = this.updateCachedBoards();\n\n    //Refactor: Change this to a function that handles rendering the board altogether so I can reuse it on gameover scene\n    //I can also just cache this screen and reuse it\n    const boardContainers = renderUtil.makeBoardContainers(\n      player1Board,\n      player2Board\n    );\n\n    this.cachedDom.mainContainer.replaceChildren(boardContainers);\n    //REFACTOR change to handleEvent on the board\n    //listener is on the board\n    const [enemyBoard] = this.cachedDom.domBoards.filter(\n      (board) => board.amIEnemy() === true\n    );\n    enemyBoard.getRenderedBoard().addEventListener(\"click\", enemyBoard);\n    //TODO implement gameover check\n\n    this.setHeader(`${Game.getCurrentPlayer().name}'s Turn`);\n  }\n  static gameOverScreen() {\n    this.cachedDom.mainContainer.classList.remove(\"player-move-phase\");\n    const [player1Board, player2Board] = this.cachedDom.domBoards;\n    player1Board.revealBoard();\n    player2Board.revealBoard();\n\n    Render.cachedDom.mainContainer.replaceChildren(\n      player1Board.getRenderedBoard(),\n      player2Board.getRenderedBoard()\n    );\n    Game.finalStatus(Game.getCurrentPlayer());\n    Game.finalStatus(Game.getEnemyPlayer());\n    Render.setHeader(`${Game.getWinner().name} is the winner`);\n  }\n}\n//TODO change to upperCase\nexport class renderUtil {\n  static makeElement(element, className, ...childs) {\n    const myEl = document.createElement(element);\n    myEl.classList.add(className);\n    if (childs) {\n      myEl.append(...childs);\n    }\n    return myEl;\n  }\n  //todo\n  static makeBoardContainers(player1Board, player2Board) {\n    const boardContainers = renderUtil.makeElement(\"div\", \"board-containers\");\n    const board1HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    const board2HeaderInfo = renderUtil.makeElement(\n      \"span\",\n      \"board-header-info\"\n    );\n    board1HeaderInfo.textContent = player1Board.player.name;\n    board2HeaderInfo.textContent = player2Board.player.name;\n    const board1InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board1HeaderInfo,\n      player1Board.getRenderedBoard()\n    );\n    const board2InfoEl = renderUtil.makeElement(\n      \"div\",\n      \"board-information\",\n      board2HeaderInfo,\n      player2Board.getRenderedBoard()\n    );\n    boardContainers.replaceChildren(board1InfoEl, board2InfoEl);\n    return boardContainers;\n  }\n\n  //TODO move this to drag and drop ?\n  static makeShipsMenu(SHIPS_TYPES) {\n    const menuElements = [];\n    for (let { name, length } of SHIPS_TYPES) {\n      // const shipViewEl = this.makeElement(\"div\", \"ship-view\");\n      let direction = \"horizontal\";\n      const shipViewEl = this.makeShipMenuImgs(length, direction);\n      //TODO finish draggable implementation\n      shipViewEl.draggable = true;\n\n      // shipViewEl.addEventListener(\"dragend\", (event) => {\n      //   const data = event.dataTransfer.getData(\"text\");\n      //   console.log(data);\n      // });\n      const shipName = this.makeElement(\"p\", \"ship-name\");\n      const shipLength = this.makeElement(\"p\", \"ship-length\");\n      const shipDirection = this.makeElement(\"p\", \"ship-direction\");\n      shipName.textContent = name;\n      shipLength.textContent = length;\n      shipDirection.textContent = direction;\n      shipViewEl.addEventListener(\n        \"dragstart\",\n        DragAndDrop.dragstartEvent(name, length)\n      );\n      shipViewEl.addEventListener(\"dragend\", DragAndDrop.dragendHandler);\n\n      const shipInfoEl = this.makeElement(\n        \"div\",\n        \"ship-info\",\n        shipName,\n        shipLength,\n        shipDirection\n      );\n      shipInfoEl.dataset.direction = direction;\n      shipInfoEl.addEventListener(\"click\", (event) => {\n        event.currentTarget.dataset.direction =\n          event.currentTarget.dataset.direction === \"horizontal\"\n            ? \"vertical\"\n            : \"horizontal\";\n\n        console.log(event.currentTarget);\n        event.currentTarget.lastElementChild.innerText =\n          event.currentTarget.dataset.direction;\n      });\n      menuElements.push(\n        this.makeElement(\"div\", \"ship-info-container\", shipViewEl, shipInfoEl)\n      );\n    }\n    const shipsMenuEl = this.makeElement(\"div\", \"ships-menu\", ...menuElements);\n    return shipsMenuEl;\n  }\n  static makeShipMenuImgs(length, direction) {\n    // const imgs = BoardRenderer.shipParts;\n    // const imgVertical = []\n    // const imgHorizontal = [BoardRenderer.shipParts.horizontalStart,BoardRenderer.shipParts]\n    document.documentElement.style.setProperty(\n      \"--max-ship-size\",\n      Game.SHIP_MAX_SIZE\n    );\n    const containerEl = renderUtil.makeElement(\"div\", \"ship-parts-view\");\n    const grid = [];\n    for (let i = 0; i < length; i++) {\n      const part = new Image();\n      if (i === 0) part.src = BoardRenderer.shipParts[direction + \"Start\"];\n      else if (i === length - 1)\n        part.src = BoardRenderer.shipParts[direction + \"End\"];\n      else part.src = BoardRenderer.shipParts[direction + \"Middle\"];\n      containerEl.append(part);\n    }\n    return containerEl;\n  }\n}\n// export class UI(){\n\n// }\n","console.log(\"hi\");\n\nimport Game from \"./game.js\";\nimport \"./style.css\";\nimport { BoardRenderer, Render } from \"./render.js\";\n\nconst mainContainer = document.querySelector(\"body\");\n\n// mainContainer.append(currentPlayerBoard.init(10, 10, \"board-container\"));\n// mainContainer.append(enemyPlayerBoard.init(10, 10, \"board-container\"));\nconsole.log(Game.SHIP_MAX_SIZE);\nRender.gameStartScreen();\n"],"names":["__webpack_require__","g","globalThis","this","Function","e","window","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","length","i","test","Error","replace","p","Ship","constructor","undefined","Number","isInteger","hit","isSunk","setDirection","direction","getDirection","Gameboard","missedShots","attacksReceived","coordinates","Map","splitColumnRow","stringCoordinates","column","row","substring","clearGameboard","value","returnVal","name","TypeError","coordinate","has","getCoordinate","get","updateCoordinate","setCoordinate","cause","newCoordinates","set","toString","placeShip","ship","coordinatesBackup","message","console","error","JSON","stringify","currentLen","receiveAttack","concat","includes","allSunk","size","log","Array","from","values","every","getRandomCoordinate","copyMissedShots","push","copyReceivedAttacks","codeUnit","charCodeAt","String","fromCharCode","parseInt","Player","gameboard","type","playerType","Logger","buildLoggerEl","getLogger","createElement","logContainer","classList","add","logMessage","playerName","spanEl","dataset","textContent","insertBefore","firstChild","logAttack","currPlayer","targetPlayer","boolHit","sunk","logStatus","enemyPlayer","sunkShips","dealtAttacks","missedHits","Game","static","SHIPS_TYPES","SHIP_MAX_SIZE","maxSize","start","mode","currentStage","players","player1","player2","currentPlayer","playerSetup","coordArray","getCurrentPlayer","allPlayersReady","switchPlayer","isPlayerReady","playerMove","attackCoordinates","waitTime","getEnemyPlayer","logger","isGameover","computerPlayerMove","generateRandomCoordinate","randomRow","Math","floor","random","gameover","some","player","finalStatus","enemy","filter","shipsSunk","Set","status","missedShotsReceived","getWinner","winner","element","getCurrentStage","oldCurrPlayer","populatePredetermined","predeterminedCoord","coord","populateGameboard","avaiableShips","shipSize","randomDirection","uniqueShipsInstances","cellsOccupied","reduce","sum","curr","MAX_SHIPS","DragAndDrop","dragstartEvent","shipName","shipLength","dataTransfer","setData","target","nextSibling","dropEffect","dragendHandler","parentElement","remove","dropEventHandler","event","preventDefault","col","shipLen","getData","shipDirection","updateBoard","err","dragoverEventHandler","BoardRenderer","rows","columns","className","renderedBoard","grouped","verticalMiddle","verticalStart","verticalEnd","horizontalStart","horizontalEnd","horizontalMiddle","init","preloadImgs","Object","shipParts","forEach","imgSrc","Image","cells","cell","isLabel","boardContainer","renderUtil","makeElement","getRenderedBoard","initListener","addEventListener","amIEnemy","groupCoordinatesByInstance","enemyView","allyView","revealBoard","gameboardInstance","playerStatus","loopBoard","missEl","replaceChildren","hitEl","renderShip","clickBoardEvent","callback","children","handleEvent","nextRenderPhase","removeEventListener","setTimeout","Render","switchingPlayerScreen","TIME_FOR_HIT_FEEDBACK","call","coordinatesByShips","instance","cellCoordinate","groupedCoord","shipInstance","shipCoordinatesArr","part","partImg","coordinatesOccupiedByShip","indexOf","result","body","querySelector","statusNav","mainContainer","domBoards","setHeader","title","cachedDom","pastMovesList","gameStartScreen","onePlayerBtn","twoPlayersBtn","nextScreen","updateCachedBoards","playerSetupScreen","board","setupDone","shipsDiv","shipsMenuEl","makeShipsMenu","populateBtn","doneBtn","clearBtn","querySelectorAll","append","nextScreenFun","time","Promise","resolve","switching","playerMoveScreen","player1Board","player2Board","boardContainers","makeBoardContainers","enemyBoard","gameOverScreen","childs","myEl","board1HeaderInfo","board2HeaderInfo","board1InfoEl","board2InfoEl","menuElements","shipViewEl","makeShipMenuImgs","draggable","shipInfoEl","currentTarget","lastElementChild","innerText","documentElement","style","setProperty","containerEl"],"sourceRoot":""}